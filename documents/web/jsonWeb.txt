Manipulação de json na web
Documentação webFunction - Foco em Manipulação de JSON
A unit webFunction oferece um conjunto de procedures e funções para a construção de strings no formato JSON de maneira procedural. A principal vantagem dessa abordagem é a simplicidade e o baixo consumo de memória, pois a manipulação é feita diretamente em uma variável do tipo String.

Conceito Principal: Construção Procedural
A lógica de construção segue um padrão simples e consistente:

Iniciar o Objeto: Use toJSonBegin para abrir um objeto ({).

Adicionar Dados: Use as procedures toJSonAdd... para inserir pares de chave/valor.

Finalizar o Objeto: Use toJSonEnd para fechar o objeto (}).

Pense nisso como montar uma caixa: você abre a caixa, coloca itens dentro um por um e, no final, fecha a caixa.

toJSonBegin(var cRes: String)Inicia um novo objeto JSON. Adiciona { à string cRes. Se cRes já contiver dados, adiciona uma vírgula antes para separar de um objeto anterior em uma lista.
toJSonAddS(var cRes, cFld, cAux)Adiciona um campo do tipo String. Ex: "campo":"valor"
toJSonAddI(var cRes, cFld, nAux)Adiciona um campo do tipo Integer. Ex: "campo":123
toJSonAddF(var cRes, cFld, nAux)Adiciona um campo do tipo Float (Real). Ex: "campo":123.45
toJSonAddD(var cRes, cFld, dAux, ...)Adiciona um campo do tipo Data (TDateTime), formatado como string. Ex: "campo":"04/08/2025"
toJSonAddB(var cRes, cFld, bAux)Adiciona um campo do tipo Boolean. Ex: "campo":true
toJSonAddJ(var cRes, cFld, cJSon, ...)Adiciona um JSON aninhado. Usado para inserir um objeto ou array JSON completo como valor de um campo.
toJSonEnd(var cRes: String)	Finaliza o objeto JSON atual, adicionando }.
toJSonArray(var cRes, cTag, ...)Envolve uma string JSON já criada em um array []. Muito útil para criar listas de objetos.
JSonText(const S: String)	Função auxiliar que "escapa" caracteres especiais em uma string (como " , \, quebras de linha) para que ela seja um valor JSON válido. As funções toJSonAddS já utilizam esta função internamente.

Com certeza! Baseado nos seus exemplos, preparei uma documentação focada exclusivamente na manipulação de JSON com a unit webFunction. A abordagem é procedural, ideal para criar estruturas JSON de forma rápida e sem a necessidade de instanciar múltiplos objetos.

Documentação webFunction - Foco em Manipulação de JSON
A unit webFunction oferece um conjunto de procedures e funções para a construção de strings no formato JSON de maneira procedural. A principal vantagem dessa abordagem é a simplicidade e o baixo consumo de memória, pois a manipulação é feita diretamente em uma variável do tipo String.

Conceito Principal: Construção Procedural
A lógica de construção segue um padrão simples e consistente:
Iniciar o Objeto: Use toJSonBegin para abrir um objeto ({).
Adicionar Dados: Use as procedures toJSonAdd... para inserir pares de chave/valor.
Finalizar o Objeto: Use toJSonEnd para fechar o objeto (}).
Pense nisso como montar uma caixa: você abre a caixa, coloca itens dentro um por um e, no final, fecha a caixa.

Procedures e Funções Essenciais
Função/Procedure	Descrição
toJSonBegin(var cRes: String)	Inicia um novo objeto JSON. Adiciona { à string cRes. Se cRes já contiver dados, adiciona uma vírgula antes para separar de um objeto anterior em uma lista.
toJSonAddS(var cRes, cFld, cAux)	Adiciona um campo do tipo String. Ex: "campo":"valor"
toJSonAddI(var cRes, cFld, nAux)	Adiciona um campo do tipo Integer. Ex: "campo":123
toJSonAddF(var cRes, cFld, nAux)	Adiciona um campo do tipo Float (Real). Ex: "campo":123.45
toJSonAddD(var cRes, cFld, dAux, ...)	Adiciona um campo do tipo Data (TDateTime), formatado como string. Ex: "campo":"04/08/2025"
toJSonAddB(var cRes, cFld, bAux)	Adiciona um campo do tipo Boolean. Ex: "campo":true
toJSonAddJ(var cRes, cFld, cJSon, ...)	Adiciona um JSON aninhado. Usado para inserir um objeto ou array JSON completo como valor de um campo.
toJSonEnd(var cRes: String)	Finaliza o objeto JSON atual, adicionando }.
toJSonArray(var cRes, cTag, ...)	Envolve uma string JSON já criada em um array []. Muito útil para criar listas de objetos.
JSonText(const S: String)	Função auxiliar que "escapa" caracteres especiais em uma string (como " , \, quebras de linha) para que ela seja um valor JSON válido. As funções toJSonAddS já utilizam esta função internamente.

Exemplo 1: Criando um Objeto JSON Simples
Vamos criar uma resposta simples, como no seu exemplo responseSale.
Snippet de código
var
  JsonResposta: String;
begin
  JsonResposta := ''; // Sempre inicie a string vazia
  toJSonBegin(JsonResposta); // Inicia o objeto -> {
  toJsonAddS(JsonResposta, 'mensagem', 'Documento recebido com sucesso');
  toJsonAddS(JsonResposta, 'dataProcessamento', dtoc(Now, True)); // Formato YYYY-MM-DD
  toJsonAddI(JsonResposta, 'codigoStatus', 200);
  toJsonEnd(JsonResposta); // Finaliza o objeto -> }
  // Resultado em JsonResposta:
  // {"mensagem":"Documento recebido com sucesso","dataProcessamento":"2025-08-04","codigoStatus":200}
end;

Com certeza! Baseado nos seus exemplos, preparei uma documentação focada exclusivamente na manipulação de JSON com a unit webFunction. A abordagem é procedural, ideal para criar estruturas JSON de forma rápida e sem a necessidade de instanciar múltiplos objetos.

Documentação webFunction - Foco em Manipulação de JSON
A unit webFunction oferece um conjunto de procedures e funções para a construção de strings no formato JSON de maneira procedural. A principal vantagem dessa abordagem é a simplicidade e o baixo consumo de memória, pois a manipulação é feita diretamente em uma variável do tipo String.

Conceito Principal: Construção Procedural
A lógica de construção segue um padrão simples e consistente:
Iniciar o Objeto: Use toJSonBegin para abrir um objeto ({).
Adicionar Dados: Use as procedures toJSonAdd... para inserir pares de chave/valor.
Finalizar o Objeto: Use toJSonEnd para fechar o objeto (}).
Pense nisso como montar uma caixa: você abre a caixa, coloca itens dentro um por um e, no final, fecha a caixa.

Procedures e Funções Essenciais manipulação de json
Função/Procedure	Descrição
toJSonBegin(var cRes: String)	Inicia um novo objeto JSON. Adiciona { à string cRes. Se cRes já contiver dados, adiciona uma vírgula antes para separar de um objeto anterior em uma lista.
toJSonAddS(var cRes, cFld, cAux)	Adiciona um campo do tipo String. Ex: "campo":"valor"
toJSonAddI(var cRes, cFld, nAux)	Adiciona um campo do tipo Integer. Ex: "campo":123
toJSonAddF(var cRes, cFld, nAux)	Adiciona um campo do tipo Float (Real). Ex: "campo":123.45
toJSonAddD(var cRes, cFld, dAux, ...)	Adiciona um campo do tipo Data (TDateTime), formatado como string. Ex: "campo":"04/08/2025"
toJSonAddB(var cRes, cFld, bAux)	Adiciona um campo do tipo Boolean. Ex: "campo":true
toJSonAddJ(var cRes, cFld, cJSon, ...)	Adiciona um JSON aninhado. Usado para inserir um objeto ou array JSON completo como valor de um campo.
toJSonEnd(var cRes: String)	Finaliza o objeto JSON atual, adicionando }.
toJSonArray(var cRes, cTag, ...)	Envolve uma string JSON já criada em um array []. Muito útil para criar listas de objetos.
JSonText(const S: String)	Função auxiliar que "escapa" caracteres especiais em uma string (como " , \, quebras de linha) para que ela seja um valor JSON válido. As funções toJSonAddS já utilizam esta função internamente.

Exemplos Práticos de Uso
Exemplo 1: Criando um Objeto JSON Simples
Vamos criar uma resposta simples, como no seu exemplo responseSale.

Snippet de código
var
  JsonResposta: String;
begin
  JsonResposta := ''; // Sempre inicie a string vazia
  toJSonBegin(JsonResposta); // Inicia o objeto -> {
  toJsonAddS(JsonResposta, 'mensagem', 'Documento recebido com sucesso');
  toJsonAddS(JsonResposta, 'dataProcessamento', dtoc(Now, True)); // Formato YYYY-MM-DD
  toJsonAddI(JsonResposta, 'codigoStatus', 200);
  toJsonEnd(JsonResposta); // Finaliza o objeto -> }
  // Resultado em JsonResposta:
  // {"mensagem":"Documento recebido com sucesso","dataProcessamento":"2025-08-04","codigoStatus":200}
end;

Exemplo 2: Criando um Objeto JSON Aninhado
Podemos aninhar o JSON do exemplo anterior dentro de outro objeto.
Snippet de código
var
  JsonPai: String;
  JsonFilho: String;
begin
  // 1. Crie o JSON filho (exatamente como no Exemplo 1)
  JsonFilho := '';
  toJSonBegin(JsonFilho);
  toJsonAddS(JsonFilho, 'mensagem', 'Sucesso');
  toJsonAddS(JsonFilho, 'data', dtoc(Now));
  toJsonEnd(JsonFilho);
  // 2. Crie o JSON pai e aninhe o filho usando toJSonAddJ
  JsonPai := '';
  toJSonBegin(JsonPai);
  toJSonAddJ(JsonPai, 'documento', JsonFilho); // Aninha o objeto
  toJsonEnd(JsonPai);
  // Resultado em JsonPai:
  // {"documento":{"mensagem":"Sucesso","data":"04/08/2025"}}
end;

Exemplo3: Como criar um json com um array

Análise: Criando um JSON com Array de Itens
O procedimento enviaPedidoCompra utiliza os componentes THProJSON e THProJSONArray para construir uma estrutura de dados complexa de forma orientada a objetos. O processo central é a criação de um array de itens que é, então, anexado ao documento principal do pedido.

O processo pode ser dividido em 4 passos principais:

Passo 1: Preparação dos Objetos JSON
Primeiro, são criados os objetos que servirão de base para a montagem do JSON. Cada um tem um papel específico:

oJson: Representa o objeto JSON principal (o "documento" do pedido).
aItens: Representa o array [] que irá conter a lista de todos os itens.
jItens: É um objeto temporário, usado dentro do loop para criar o JSON de um único item de cada vez.

Passo 2: Preenchimento dos Dados Principais do Documento
Os campos do objeto principal (oJson) são preenchidos com as informações do pedido, como companyId, documentId, etc.

Snippet de código
oJson.Clear;
with oJson do begin
  AddText('companyId', InttoStr(Pedido.nEmpresa));
  AddText('documentId', Pedido.cNumero);
  AddText('type', Pedido.cTipo);
  // ... outros campos do pedido
end;

Passo 3: Construção do Array de Itens (O Processo Central)
Esta é a parte principal. Um loop for percorre cada item do pedido (aItem) para construir o array.

Dentro do loop:
O objeto temporário jItens é limpo para garantir que não haja dados do item anterior.
jItens é preenchido com os dados do item atual (id, textName, etc.).
A etapa-chave: O JSON do item atual (jItens.JSon) é adicionado ao array aItens com o comando aItens.Add(). O componente aItens gerencia automaticamente a sintaxe do array, adicionando as vírgulas necessárias entre os objetos.

Snippet de código
aItens.Clear;
for I := 0 to High(aItem) do
begin
  // Limpa o objeto temporário para o item atual
  jItens.Clear;
  // Preenche o objeto 'jItens' com os dados do item
  with jItens do
  begin
    AddInteger('id', aItem[I].nProduto);
    AddInteger('textId', aItem[I].nProduto);
    AddText('textName', aItem[I].cDescricao);
  end;
  // Adiciona o JSON do item recém-criado ao array 'aItens'
  aItens.Add(jItens.JSon);
end;

Passo 4: Anexando o Array de Itens ao Objeto Principal
Após o loop, o objeto aItens contém o array completo de itens. Este array é então inserido no objeto principal oJson através do método AddArray.

Snippet de código
// 'aItens.JSon' retorna a string completa do array: "[{...}, {...}]"
oJson.AddArray('items', aItens.JSon);


Extraindo e Manipulando JSON
Funções Standalone: Lendo e Manipulando JSON
Use estas funções quando você já tem uma string JSON e precisa extrair informações dela ou formatá-la.

Funções de Extração de Dados em um json
Função	Descrição
ExtractJSon(cJSon, cTag)	A função mais importante. Extrai o valor de uma chave (cTag) de uma string JSON. Retorna o valor como string.
ExtractJSonInteger(cJSon, cTag)	Extrai um valor e o converte para inteiro.
ExtractJSonFloat(cJSon, cTag)	Extrai um valor e o converte para real.
ExtractJSonBool(cJSon, cTag)	Extrai um valor e o converte para booleano.
ExtractJSonDate(cJSon, cTag)	Extrai uma data (string) e a converte para TDate.
ExtractJSonDateTime(cJSon, cTag)	Extrai data/hora (string) e a converte para TDateTime.

Funções para Trabalhar com Arrays no JSON, extraindo
ExtractJSonElement(var cJSon, nElement)	Extrai um elemento específico de um array JSON pelo seu índice (inicia em 1). Atenção: Esta função pode modificar a string cJSon internamente para otimizar a busca sequencial.
ExtractJSonElementCount(var cJSon)	Conta quantos elementos existem em um array JSON.
JSonArray(cJSon)	Converte um array JSON simples (ex: ["a", "b", "c"]) em um TArrayOfString do Delphi.

Exemplo Prático de Leitura e Extração
Vamos usar a string JSON que criamos no exemplo anterior para ler seus dados.

Snippet de código

procedure LerDadosDaFatura(const JsonString: String);
var
  // Variáveis para armazenar os dados lidos
  IdFatura: Integer;
  Cliente: String;
  EstaPaga: Boolean;

  // Variáveis para o loop do array
  JsonArrayProdutos: String;
  JsonProdutoAtual: String;
  Indice: Integer;
begin
  // 1. Extrair dados simples do objeto principal
  IdFatura := ExtractJSonInteger(JsonString, 'id_fatura'); // Retorna 1025
  Cliente  := ExtractJSon(JsonString, 'cliente');        // Retorna "ACME Corp"
  EstaPaga := ExtractJSonBool(JsonString, 'pago');         // Retorna False

  // 2. Extrair o array 'produtos' como uma string separada
  JsonArrayProdutos := ExtractJSon(JsonString, 'produtos');
  // Conteúdo de JsonArrayProdutos: [{"sku":...},{"sku":...}]

  // 3. Iterar sobre os elementos do array
  Indice := 1;
  while True do
  begin
    // Extrai o objeto do produto no índice atual
    JsonProdutoAtual := ExtractJSonElement(JsonArrayProdutos, Indice);

    // Se não encontrar mais elementos, sai do loop
    if JsonProdutoAtual = '' then Break;

    // Agora, extrai os dados de dentro do objeto do produto
    ShowMessage('SKU: ' + ExtractJSon(JsonProdutoAtual, 'sku'));
    ShowMessage('Qtd: ' + ExtractJSon(JsonProdutoAtual, 'quantidade'));

    // Incrementa o índice para o próximo elemento
    Inc(Indice);
  end;
end;

Funções de Formatação e Conversão
Função	Descrição
CompressJSon(cJSon)Remove todos os espaços e quebras de linha de uma string JSON, tornando-a compacta para envio.
ExpandJSon(cJSon)Formata uma string JSON compacta com indentação e quebras de linha, tornando-a legível para humanos (ideal para debug e logs).
EncodeJSon(cJSon)Codifica caracteres especiais (como \, ", quebras de linha) para o formato de escape do JSON.
DecodeJSon(cJSon)Decodifica os caracteres de escape de volta para seus valores originais.

Documentação Técnica: Extração de Arrays em webJSon
Este documento descreve o processo técnico para extrair e iterar sobre os elementos de um array JSON aninhado dentro de um objeto, utilizando as funções da unit webJSon.

Visão Geral do Processo
A extração de um array aninhado é um processo de duas etapas que utiliza um par de funções principais: ExtractJSon e ExtractJSonElement.

Isolamento do Array: A função ExtractJSon é usada para localizar a chave do array e extrair seu valor completo como uma sub-string.

Iteração dos Elementos: A função ExtractJSonElement é usada em um loop para extrair cada elemento individual da string do array isolada na etapa anterior.

Funções Fundamentais
1. ExtractJSon
Assinatura: function ExtractJSon(cJSon: String; const cTag: String; ...): String;

Objetivo: Localiza uma chave (cTag) em uma string JSON (cJSon) e retorna seu valor correspondente.

Comportamento com Arrays: Quando o valor associado à cTag é um array JSON, a função retorna a representação completa do array como uma única String, incluindo os colchetes de abertura e fechamento ([ e ]).

2. ExtractJSonElement
Assinatura: function ExtractJSonElement(var cJSon: String; nElement: Integer; ...): String;

Objetivo: Extrai um único elemento de uma string que representa um array JSON.

Parâmetros:

cJSon: Uma String que deve conter um array JSON válido (ex: "[{},{},...]")

nElement: O índice do elemento a ser extraído. Este é um índice de base 1 (o primeiro elemento é o de índice 1).

Retorno:

Se o elemento for encontrado, retorna a String JSON do objeto ou valor naquele índice.

Se o índice (nElement) estiver fora dos limites do array, a função retorna uma string vazia (''). Este comportamento é a condição de parada para loops de iteração.

Algoritmo de Extração e Iteração
O padrão canônico para processar um array aninhado é o seguinte:

Passo 1: Isolar a String do Array
Utilize ExtractJSon para obter a string do array a partir do JSON de entrada.

Snippet de código

var
  JsonInput: String;      // Contém o JSON completo: {"key":"value", "array_key":[{...}]}
  JsonArrayString: String; // Receberá a string do array: "[{...}]"

JsonArrayString := ExtractJSon(JsonInput, 'array_key');
Passo 2: Iterar sobre os Elementos do Array
Implemente um loop que utilize um contador de índice para chamar ExtractJSonElement repetidamente.

Snippet de código

var
  JsonElemento: String;
  Indice: Integer;

Indice := 1; // A extração começa no índice 1.
while True do
begin
  // Tenta extrair o elemento na posição 'Indice'
  JsonElemento := ExtractJSonElement(JsonArrayString, Indice);

  // Se o resultado for uma string vazia, todos os elementos foram lidos.
  if JsonElemento = '' then
    Break; // Termina o loop.

  // [ Processamento do JsonElemento aqui ]

  // Prepara para a próxima iteração.
  Inc(Indice);
end;
Passo 3: Processar o Elemento Individual
Dentro do loop, a variável JsonElemento contém o JSON de um único item. Use as funções ExtractJSon, ExtractJSonInteger, etc., novamente nesta string menor para extrair os dados finais.

Snippet de código

// Dentro do loop 'while'...
var
  ValorChave: String;
  ValorNumerico: Integer;

ValorChave := ExtractJSon(JsonElemento, 'chave_do_item');
ValorNumerico := ExtractJSonInteger(JsonElemento, 'chave_numerica_do_item');
Exemplo de Código Canônico
O procedimento a seguir implementa o algoritmo completo para extração e processamento de um array.

Snippet de código

procedure ExtrairEProcessarArray(const JsonInput: String; const ChaveDoArray: String);
var
  // Strings para armazenar as partes do JSON
  JsonArrayString: String;
  JsonElementoString: String;

  // Variáveis de controle e para dados extraídos
  Indice: Integer;
  ID: Integer;
  Nome: String;
begin
  // Etapa 1: Isola a string do array associada à chave especificada.
  JsonArrayString := ExtractJSon(JsonInput, ChaveDoArray);

  // Validação: Interrompe a execução se o array não for encontrado.
  if JsonArrayString = '' then
    Exit;

  // Etapa 2: Itera sobre a string do array.
  Indice := 1; // O índice de 'ExtractJSonElement' começa em 1.
  while True do
  begin
    // Extrai o JSON do elemento individual na posição 'Indice'.
    JsonElementoString := ExtractJSonElement(JsonArrayString, Indice);

    // Condição de término: Uma string vazia indica o fim do array.
    if JsonElementoString = '' then
      Break;

    // Etapa 3: Extrai os dados de dentro do JSON do elemento.
    ID   := ExtractJSonInteger(JsonElementoString, 'id');
    Nome := ExtractJSon(JsonElementoString, 'nome');

    // [ Neste ponto, os dados do elemento (ID, Nome) podem ser utilizados ]
    // Exemplo: Log.Add(Format('Elemento %d: ID=%d, Nome=%s', [Indice, ID, Nome]));

    // Avança para o próximo elemento.
    Inc(Indice);
  end;
end;

// --- Uso do Procedimento ---
var
  MeuJson: String = '{"relatorio_id":998, "dados":[{"id":10, "nome":"Item A"}, {"id":25, "nome":"Item B"}]}';
begin
  ExtrairEProcessarArray(MeuJson, 'dados');
end;

Exemplo de codigo, extraindo um array de um json recebido.
procedure addSaleItems(cReq: String);
var cArrayItems : String;
    cItem       : String;
    nInd        : String;
begin
     nInd := 1;
     cArrayItems := Extractjson(cReq, 'Items');
     while true do begin
        cItem =: ExtractJSonElement(cArrayitems, nInd);
        if cItem = '' then begin
           break;
        end;
        addSaleItemAux(cItem);
        nInd := nInd + 1;
     end;
end;



