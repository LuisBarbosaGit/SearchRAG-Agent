# INTEGRAÇÃO

**Última alteração:** Setembro/2023

## CONCEITOS BÁSICOS DE PROGRAMAÇÃO EM DELPHI

O objetivo deste material é oferecer uma introdução sobre a base necessária para se trabalhar com as ferramentas e conceitos utilizados pela HPro Informática no quesito técnico de implementação dos sistemas. A ideia principal não é o aprofundamento dos tópicos citados, mas sim, orientar a equipe participante do processo de integração nesses diversos assuntos. Os tópicos abordados estão listados a seguir.

  * Programando em Delphi
  * Estrutura de um projeto
  * Estrutura do código
  * Tipos de dados
  * Escopo de variáveis
  * Procedures e Functions
  * Tipos de parâmetros

### Estrutura de um projeto

A estrutura de um projeto em Delphi é composta pelos arquivos DPR (arquivo de projeto Delphi), PAS (arquivos-fonte com código em pascal - conhecido também como unit), DFM (arquivos-fonte que representam o formulário associado ao arquivo PAS), DCU (código-objeto gerado a partir dos arquivos PAS e DFM) e RES (arquivo de recursos do projeto - onde é armazenado o ícone do projeto, exemplo).

  * **Processo de compilação** = DPR + RES + PAS + DFM = DCU
  * **Processo de link-edição** = DCU + (arquivos da biblioteca do Delphi) = EXE

**Nota:** Todos os arquivos iniciados com o sinal \~ (til) são arquivos de backup e podem ser apagados. Os demais arquivos geralmente não são relevantes, mas é recomendado não excluir nenhum arquivo contido na pasta do projeto.

### Tipos de Dados

O Delphi oferece uma vasta lista de tipos de dados. Esses tipos de dados podem ser divididos em categorias. Para maiores informações sobre a representação desses tipos de dados, recomenda-se buscar a documentação da versão do Delphi com a qual se está trabalhando. As versões mais modernas do Delphi oferecem as seguintes categorias:

**Representação de números inteiros**

  * Byte
  * ShortInt
  * Word
  * SmallInt
  * Cardinal
  * LongWord
  * FixedUInt
  * **Integer (Padrão HPro)**
  * LongInt
  * FixedInt
  * UInt64
  * Int64
  * NativeUInt
  * NativeInt

**Representação de número com ponto-flutuante**

  * Single
  * Double
  * Extended
  * **Currency (Padrão HPro)**
  * **Real (Padrão HPro)**

**Representações de Strings e Caracteres**

  * AnsiChar
  * Char
  * WideChar
  * AnsiString
  * RawByteString
  * UnicodeString
  * **String (Padrão HPro)**
  * ShortString
  * WideString

**Representação de arquivos**

  * File
  * TextFile, Text

**Representação de tipos de dados lógicos**

  * **Boolean (Padrão HPro)**
  * ByteBool
  * WordBool
  * LongBool

**Outros tipos de dados**

  * **Array (Padrão HPro)**
  * **Record (Padrão HPro)**
  * Variant
  * Pointer

### OOP – Programação Orientada a Objetos

  * Classes (fábrica de objetos), objetos, propriedades, métodos e eventos
  * Componentes (visuais e não-visuais)

### Teoria de conjuntos (junções e uniões) (4 x 3 = 12)

  * O que é buffer e para que serve
  * Escopo de variáveis

### O que é um arquivo de dados

**Exemplo:**

# **CADASTRO DE CLIENTES**

  * COD - CODIGO
  * NOM - NOME
  * DAN - DATA DE NASCIMENTO

# **ESTRUTURA DA TABELA CLIENTES**

**CABEÇALHO**

  * NUMERO DE REGISTROS: String(4)
  * DATA DA ULTIMA ATUALIZACAO: String(8) // 20110111
  * HORARIO DA ULTIMA ATUALIZACAO: String(6) // 104120
  * TAMANHO DO REGISTRO (EM BYTES): String(2)
      * 20 bytes

**REGISTRO**

  * EXC - Excluído: String(1)
  * COD - INTEGER: String(4)
  * NOM - STRING(12): 12 bytes
  * DAN - TDATETIME: String(8)
      * 25 bytes

# **ESTRUTURA EM BYTES**

\---- Cabeçalho -----
`0000`
`AAAAMMDD`
`HHMMSS`
`TR`

`00002011011110450025`

| COD | NOME |
| :-- | :--- |
| 1 | Aline |
| 2 | Daniel |
| 3 | Leandro |

`00032011011110482025N 1Aline 20000101N 2Daniel 20000101N 3Leandro 20000101`

  * Buffer Aline = N 4Eduardo 20000101
  * Buffer Daniel = N 4eduardo 20000101
  * Buffer Leandro = N 4EDUARDO 20000101
  * Buffer Renata = N 3Leandro 20000101

**Estrutura de um arquivo de dados (tabela). Cabeçalho + Registros**

Tamanho de uma tabela = tamanho do cabeçalho + (nº de registros \* tamanho do registro)

## MÓDULOS DE UM SISTEMA DE BANCO DE DADOS

  * Inclusão
  * Alteração
  * Consultas/Relatórios
  * Exclusão/Cancelamento/Estornos
  * Relatórios gerenciais

### Conceitos básicos de banco de dados

  * Tabelas
  * Campos

**Comparando conceitos de planilhas (Excel) com banco de dados**

| EXCEL | BANCO DE DADOS |
| :--- | :--- |
| Arquivo XLSX | Banco de dados (Database) |
| Planilha(s) | Tabela(s) |
| Colunas | Campos (atributos) |
| Linhas | Registros |

  * Ponteiro de registros
  * Métodos padrão: Open, Append, Edit, Post, Cancel, Delete, Close
  * “Estados” padrão: dsInsert, dsEdit, dsBrowse, dsInactive
  * Métodos de ponteiro de registro: First, Last, Next, Prior, FindKey
  * Diferença entre MoveBy e Next
  * Índices
  * Chave primária
  * Chaves secundárias
  * Chaves compostas
  * Índices descendentes
  * Índices case-insensitive
  * Ordenação dos dados para exibição
  * Campos obrigatórios (no banco de dados x definido no código)
  * Integridade referencial (no banco de dados x definido no código)
  * Campos calculados (virtual)
  * Ranges
  * Transações (Transaction, Commit, RollBack)
  * Transações (Completa x Restrita)
  * Live result x Canned result
  * Conceito de situação (pendente, emitido, cancelado)
  * Conceito de movimento (caixa, estoque, extrato bancário)

## CONCEITOS IMPORTANTES

### Tabelas do banco de dados:

As tabelas são armazenadas em arquivos com a extensão DAT, os índices (TODOS) são armazenados em um único arquivo com a extensão IDX e o(s) campo(s) memo (se existirem) são armazenados em um único arquivo com a extensão BLB. Se não existirem campos memo não existirá o arquivo com a extensão BLB.

Para o ElevateDB basta acrescentar um “e“ como prefixo ficando como eDat, eBlb, eIdx.

### Tipos de dados:

Os tipos de dados utilizados pelo DBISAM podem ser resumidos nos seguintes:

  * **Integer:** para representar números inteiros
  * **BCD:** para representar números com até 4 casas decimais com precisão
  * **Float:** para representar números com o maior número de casas decimais, porém o mesmo deverá ser evitado, visto que poderemos estar visualizando 2,00 na tela e o valor armazenado no campo ser 1,99999999999999999999)
  * **Date:** para representar datas
  * **String:** para representar campos caracteres com tamanho fixo de caracteres
  * **Memo:** idem ao campo string sem quantidade de caracteres definida

### Transações:

É um processo que visa a garantia de conclusão completa de um conjunto de instruções para atualizações de tabelas. Em outras palavras, define-se o início da transação (usando D.Transaction), efetua-se o processamento das atualizações de tabelas (quantos forem necessários) e em seguida finaliza-se a transação (usando D.Commit). Se houver qualquer erro ou interrupção do processo o banco de dados automaticamente efetuará um ROLLBACK (cancelamento de transação) e o estado do banco de dados volta a situação imediatamente anterior ao início da transação.

### Concorrência de acesso aos dados:

Atualmente é quase impossível pensar em um sistema de informação que seja utilizado por apenas um único usuário. Os sistemas atuais são utilizados por vários usuários simultaneamente e a situação de concorrência durante o acesso aos dados é muito comum. O que ocorre com muita frequência é a inclusão simultânea de dados de um mesmo módulo por 2 ou mais usuários. O próprio banco de dados gera um erro quando ocorrer duplicidade de chave primária, porém se quisermos evitar o aparecimento da mensagem de erro ao usuário e o módulo em questão permitir, o componente HPROTABLE poderá gerar a próxima chave disponível fazendo com que o processo fique transparente para os usuários. Para definir este comportamento basta inserir o código `Tabela.AutoPrimaryKey := True` imediatamente antes de se chamar o método Tabela.Post. Exemplo: 4 usuários iniciam a inclusão de um cliente e o sistema sugere código 1 para os 4 usuários. Se a propriedade AutoPrimaryKey estiver em False, o segundo usuário a gravar receberá uma mensagem de erro informando que o registro já foi incluído por outro usuário, mas se o mesmo estiver em True, então os 4 usuários obterão sucesso durante a inclusão gerando os códigos 1, 2, 3, 4 conforme o acesso de cada um deles. Para o processo em que 2 ou mais usuários acessem o mesmo registro de uma mesma tabela ao mesmo tempo para edita-lo ou excluí-lo, então o primeiro usuário obterá sucesso, e os demais receberão a mensagem “Registro alterado ou excluído por outro usuário”.

### Validação de campos/formulários:

Praticamente está se tornando um padrão não validar os campos durante a digitação do usuário. Em programação para ambiente não gráfico (DOS) esta validação era mais simples pois somente o teclado estava disponível para o usuário fazendo com que a validação acontecesse imediatamente a digitação de um campo pelo usuário. Porém com o Windows a utilização do mouse pode mudar o foco do campo em questão para outro campo gerando inúmeras possibilidades de validação e se tornando complexo. Sempre que for possível a validação deverá ocorrer no botão Gravar ou OK. Isto é, deixe o usuário digitar o que ele quiser. Após ele clicar no botão Gravar ou OK o sistema terá TOTAL controle sobre o processo e as validações poderão ser efetuadas uma única vez.

### Integridade referencial:

Esta é uma característica de um bom banco de dados. A integridade referencial evitará por exemplo a exclusão de um cliente que já foi utilizado para emissão de notas fiscais, a exclusão de um produto que já foi utilizado para o estoque, etc. Para que isto seja possível é importante ao definirmos cada campo de uma tabela se ele tem associação com outra tabela. No exemplo acima, quando falamos em itens da nota fiscal, devemos referenciar o cadastro de produto. Desta maneira quando da exclusão de um produto o sistema irá verificar a sua existência no cadastro de itens de notas fiscais, se existir o sistema emitirá um aviso ao usuário informando que o registro NÃO poderá ser excluído devido ao fato de existir vínculos com outras tabelas.

### Campos obrigatórios:

Preferencialmente os campos obrigatórios devem ser definidos diretamente no Genfiles, isto é, deverão ser controlados internamente pelo DBISAM. Porém existem casos em que o usuário solicita o bloqueio de um determinado campo com a tabela já contendo dados. Nestes casos, o bloqueio deverá estar dentro do programa e será responsabilidade do programador. Se por engano for definido campo obrigatório no banco de dados e o mesmo possuir registros em que este campo NÃO contenha informação, estes serão eliminados.

### Excluindo registros:

Após a exclusão de um registro, o DBISAM não permite a recuperação do mesmo. Internamente o mesmo é marcado como excluído e será utilizado pelo DBISAM quando de uma nova inclusão. Porém em determinados casos onde existem muitas exclusões e poucas inclusões, o arquivo permanecerá com o mesmo tamanho no disco. Se houver necessidade de realmente eliminar o espaço ocupado pelos registros excluídos pode-se aplicar o método Tabela.OptimizeTable. Porém este método é muito pouco utilizado e o mesmo deverá ser utilizado em casos extremos.

### Índices:

O DBISAM é um banco de dados extremamente rápido. Porém o mesmo deverá ter índices disponíveis para efetuar o processamento com rapidez. Para referenciar mais de um campo em um índice deve-se utilizar o sinal `;` para separar os campos. Exemplo: `CLI;DAT` referenciará os campos CLI e DAT. Um outro comentário importante a fazer é em relação à utilização dos índices durante o processamento de instruções SQL. O DBISAM utiliza somente o primeiro campo de QUALQUER índice para otimizar a pesquisa. Portanto para uma pesquisa envolvendo o campo CLI, (conforme o exemplo acima) o SQL será otimizado; porém se houver pesquisa no campo DAT o mesmo NÃO será otimizado, fazendo com que outro índice deva ser criado iniciando com o campo DAT.

### FindKey x Locate:

Estes métodos são utilizados para localizar registros em tabelas ou queries. O método FindKey funciona somente em tabelas enquando que o Locate funciona tanto em tabelas quanto em queries. Enquanto o método FindKey utiliza o índice atual da tabela para pesquisar, o método Locate utiliza o índice se o mesmo existir, mas se não for encontrado índice para otimizar a pesquisa, então a pesquisa será feita registro a registro, tornando-a muito lenta.

### Utilizando faixas de dados (RANGE):

Este método é utilizado para “extrairmos” uma faixa de dados de uma determinada tabela. A tabela necessariamente precisa estar indexada pelo campo que será utilizado para definir a faixa. O método utilizado é o SETRANGE e o método utilizado para cancelar a faixa é o CANCELRANGE. Deve-se lembrar que após o RANGE, o índice NÃO poderá ser mudado pois caso isto acontecer o RANGE é automaticamente cancelado. Outra consideração importante é que todos os métodos na tabela utilizada funcionarão somente dentro da faixa definida. First, Last, Next, Prior, Eof, Bof, FindKey, Locate somente pesquisarão na faixa extraída da tabela.

### Mudando o ponteiro de registros:

Para mudarmos o ponteiro de registros em uma tabela ou query devemos usar os seguintes métodos: First (posiciona no primeiro registro do índice ativo) , Next (move o ponteiro para o próximo registro do índice ativo), Prior (move o ponteiro para o registro anterior do índice ativo), Last (move o ponteiro para o último registro do índice ativo). As flags BOF e EOF somente serão ativadas quando estar posicionado no primeiro registro e tentar mover para o anterior (flag BOF será ligado), ou quando estivermos no último registro e tentarmos mover para o próximo (flag EOF será ligado).

### Tabelas x Queries:

Uma dúvida muito comum é quando devemos usar um e quando devemos usar o outro. A princípio devemos usar tabelas para efetuar a manutenção de dados nas tabelas. Para efetuarmos consultas, onde poderemos aplicar os mais diversos critérios e ordens possíveis, devemos utilizar as queries pois serão mais eficientes além de possibilitar constantes ajustes (conforme as solicitações dos usuários). Devemos lembrar que SEMPRE o acesso utilizando tabelas será mais rápido, porém mais trabalhoso em alguns casos. Deve-se planejar o que será feito e decidir qual será melhor para utilizar. Não existe uma regra geral que resolva todos os casos. Para o caso das queries não podemos esquecer da otimização dos índices que foi citada anteriormente. Se não existirem índices para agilizar o processo então o processamento será EXTREMAMENTE lento.

### Filtros:

Apesar de existir no DBISAM, deve-se evitar o uso de filtros. Na grande maioria dos casos conseguimos obter os resultados desejados utilizando Tabelas com índices ou códigos SQL. Porém o recurso do filtro está disponível através do evento OnFilterRecord.

### Campos calculados (virtuais) X Join (SQL com mais de 1 tabela):

Por questões de desempenho, muitas vezes podemos evitar a situação de utilizar o SQL com mais de uma tabela. Para isto podemos e devemos estar utilizando os campos calculados nas queries. Somente será necessário efetuar SQL com mais de uma tabela quando existir a necessidade de ordenar o resultado pelos campos de outras tabelas.

### Processamento vinculado à impressão de documentos (notas fiscais, boletos, duplicatas, etc):

Sempre que houver a necessidade de efetuar o processamento de informações vinculadas à impressão de documentos devemos efetuar o processamento APÓS a impressão utilizando o seguinte código:

```delphi
if Imp.Start and Imp.Printed then begin
  D.Transaction;
  // Efetua o processamento
  D.Commit;
end;
```

## MODELO E-R (CONCEITO E APLICAÇÃO)

É um modelo abstrato cuja finalidade é descrever, de maneira conceitual, os dados a serem utilizados em um Sistema de Informações ou que pertencem a um domínio. A principal ferramenta do modelo é sua representação gráfica, o Diagrama Entidade Relacionamento. Normalmente o modelo e o diagrama são conhecidos por suas siglas: MER e DER.

Existem muitas notações para Diagrama de Entidades e Relacionamentos. A notação original é composta de entidades (retângulos), relacionamentos (losangos), atributos (círculos) e linhas de conexão (linhas) que indicam a cardinalidade de uma entidade em um relacionamento.

Os tipos de relações utilizadas neste diagrama são:

  * **Relação 1..1 (lê-se relação um para um)** - indica que as tabelas têm relação unívoca entre si. Você escolhe qual tabela vai receber a chave estrangeira;
  * **Relação 1..n (lê-se um para muitos)** - a chave primária da tabela que tem o lado 1 vai para a tabela do lado N. No lado N ela é chamada de chave estrangeira;
  * **Relação n..n (lê-se muitos para muitos)** - quando tabelas têm entre si relação n..n, é necessário criar uma nova tabela com as chaves primárias das tabelas envolvidas, ficando assim uma chave composta, ou seja, formada por diversos campos-chave de outras tabelas. A relação então se reduz para uma relação 1..n, sendo que o lado “n” ficará com a nova tabela criada.

### Exercício I:

Criar modelo E-R para uma administradora de condomínios.

**Considerações:**

  * Um condomínio é formado por diversas unidades habitacionais;
  * Cada unidade habitacional pertence a um condômino, o qual pode ser proprietário de várias unidades;
  * Cada unidade pode ser alugada;
  * Toda pessoa (condômino ou locatário) possui um código, nome e endereço;
  * Toda unidade possui um código que a identifica no condomínio;
  * Um condomínio é identificado por um código e um endereço.

### Exercício II:

Criar modelo E-R para controlar o movimento de um bar/restaurante.

**Considerações:**

  * Emitir a conta quando solicitada pelos garçons, por mesa
  * Controlar a gorjeta dos garçons;
  * Identificar os pratos e bebidas mais consumidos pelos fregueses;
  * Enviar um cartão de natal aos fregueses no final do ano;
  * Listar o movimento diário do bar/restaurante.

### Exercício III:

Criar modelo E-R para controlar o movimento de um hotel.

**Considerações:**

**Quanto ao hóspede:**

  * Possui um nome, local de origem, local de destino, motivo da viagem, data de entrada no hotel, identificação do apto ocupado por ele. Ele pode efetuar reservas para sua estadia desde que especificada a data de chegada e o provável período que ficará hospedado.

**Quanto ao hotel:**

  * Possui vários apartamentos, sendo que estes podem ser de 3 tipos: single, double e suítes presidenciais, variando o valor de estadia para cada um dos tipos. Cada apartamento possui alocado a ele produtos e equipamentos para utilização e consumo dos hóspedes.
  * O hotel possui serviços de restaurante, bar, sauna, piscina coletiva, salão de beleza, lavanderia e copa. Os serviços utilizados pelos hóspedes podem ser debitados em sua conta de serviços.
  * O hotel mantém estoque de produtos tanto para alimentação quanto de materiais de limpeza e para utilização dos hóspedes.

**Quanto a conta do hóspede:**

  * Todo hóspede do hotel possui dois controles de conta: a conta das diárias e a conta dos serviços.
  * Na conta das diárias são lançados os valores referentes às diárias vencidas todos os dias às 12 horas. Na conta de serviços são lançados os valores de consumo de frigobar, restaurante, bar, etc. Os materiais extras solicitados pelos hóspedes, como 3ª cama, toalhas adicionais, são lançados como serviços extras.
  * Quanto ao fechamento da conta de um hóspede, as despesas de estadia podem ser faturadas ou pagas à vista. Deve-se controlar se o pagamento foi realizado com cheque ou em espécie (dinheiro). As despesas extras não admitem faturamento (prazo).

**Quanto as reservas:**

  * Todas as reservas devem indicar o nome do hóspede, quem efetuou a mesma (agência de turismo, etc), a data solicitada para chegada e o tipo de acomodação desejada. Não podem existir reservas para períodos sem que exista disponibilidade.

## FERRAMENTAS DE PROGRAMAÇÃO

  * **GenAplic:** Tem como objetivo gerar o programa inicial para o início do desenvolvimento de um projeto. Ele é responsável por definir o nome do arquivo de projeto (DPR), o nome do sistema, o título da aplicação e criação da pasta onde serão hospedados TODOS os arquivos do projeto (se a mesma não existir).
  * **GenFiles:** Tem como objetivo gerar uma documentação do projeto, especificando tabelas, campos, índices, integridade referencial além de ser um gerador de código completo. Todas as rotinas relacionadas com a criação de tabelas, criação e/ou alteração de campos, criação e/ou alteração de índices, reorganização de arquivos, máscaras, campos obrigatórios, além de outros recursos são automaticamente gerados por este utilitário.
  * **GenForm:** Gerador de formulários completo. Baseado nas informações inseridas, gera todo o código para agilizar o desenvolvimento de um projeto. Desta forma o foco do desenvolvedor estará apenas na solução do problema.
  * **DBM – Database Manager:** Utilitário com o objetivo de gerenciar todo o banco de dados com suas tabelas, campos e índices de maneira direta, permitindo a criação de novas tabelas, alteração na estrutura das mesmas, criação e/ou atualização de índices e reparação de tabelas com problemas. Possui diversos recursos práticos para o desenvolvedor localizar registros, mudar o índice ativo, executar “ranges”, filtrar a tabela, gerar código SQL, executar códigos SQL, dentre muitos outros recursos. É o gerenciador do banco de dados DBISAM.
  * **eDBM – Database Manager:** É o equivalente ao DBM mas para o banco de dados ELEVATEDB.
  * **RPServer:** Serviço instalado junto com o aplicativo servidor do banco de dados. É utilizado para processamento de funções diretamente na base de dados sem envolver tráfego de rede. Utilizado também para efetuar tarefas agendadas, processamentos noturnos,etc.
  * **HProEdit:** Editor de textos multi-janelas com diversos recursos interessantes para análise de arquivos texto, XML, JSON, etc. É um bloco de notas melhorado.
  * **HProWS, HWServer (antigo):** Servidor web desenvolvido integralmente pela HPro Informática. Características:
      * alta disponibilidade (multi-thread) e funciona como serviço do Windows
      * provê integração entre a Internet e o banco de dados interno utilizando como linguagem o Delphi padrão (com todos os recursos necessários);
      * utiliza poucos recursos do equipamento (memória e processamento);

## FUNCIONAMENTO DE UMA EMPRESA

### ESQUEMA SIMPLIFICADO

## Desenvolvendo um cadastro simples

  * **Estrutura**
      * Código (inteiro)
      * Nome (string com 40 posições)
      * Data de nascimento (data não obrigatória)
      * Observação (memo) (deve ser colocado depois para mostrar alteração)
  * **Entendendo o código gerado**
      * Formulário MDI x Modal
      * Chamando formulário MDI
      * Chamando formulário modal
      * Entendendo uCad01
      * Entendendo uCad02
      * Entendendo o conceito de exibição do grid
      * Entendendo o conceito de impressão automática

## Explanação do formato geral do aplicativo

  * Menus
  * Cadastro de usuários
  * Direitos de acesso
  * Parâmetros dos usuários
  * Cópias de segurança
  * Consultas avançadas
  * Menu sobre
  * Impressão automática x Impressão manual
  * Impressão de bordas e imagens (logotipos, códigos de barra, etc.)

## Customizações diversas

  * DBGrid customizado (Ctrl+E, etc)
  * HProButton
  * Validação de datas (MaskEdit e DBEdit)
  * Validação de valores (DBEdit)

## Considerações diversas

  * Edit x HProView e DBEdit x HProView (uso do OnExit x OnSelect)
  * Evento OnChange
  * Usar o nome do campo ao invés do nome do componente (quando ligado a dados)
  * Usando o depurador (debug)
  * Criar uma situação de 1 x N para explicação de campo calculado
  * Criar consulta explicando range por período e range com cliente + período

## Diretrizes gerais

  * Nunca usar Range em tabelas do DataModulo
  * Nunca mudar o índice de tabelas do DataModulo
  * Nunca programar no DataModulo
  * Grids devem sempre estar ligados a tabelas locais
  * Tabelas sempre devem ser abertas no evento OnCreate do formulário
  * Índices devem ser definidos no momento da abertura da tabela em quase 100% das vezes
  * Nomes de tabelas/campos devem seguir as recomendações (ver anexos no final deste documento)
  * Em todas as consultas que contemplem valores devemos ter o botão totalizar
  * Onde houver valores os mesmos deverão ser totalizados na impressão
  * Ao utilizar máscaras, deve-se sempre salvar os dados sem os caracteres da máscara:
      * Exemplo: 05/002 será armazenado no banco de dados como 05002.

## DIRETRIZES VISUAIS

  * Largura de Edit/DBEdit que representam códigos (no mínimo 45 pixels)
  * Largura do View (300 pixels)
  * Largura de MaskEdit/DBEdit que representam datas (75 pixels)
  * Largura de EditNum/DBEdit que representam valores com casas decimais (no mínimo 75 pixels)
  * Máscara padrão para valores \#,\#\#\#,\#\#0.00
  * ComboBox (DropDownList e Largura)
  * Cores/Fontes/Estilo/Tamanho
  * GroupBox (título em azul)
  * Grid (código + descrição)
  * Situação x Consultas
  * Grid (largura, barra de rolagem horizontal)
  * Botão Processar atuante no FormShow
  * Abreviações/Labels
  * Ordem dos campos na chave primária (Genfiles)
  * Continuidade do processamento x Intervenção do usuário durante a transação
  * Critérios nos relatórios
  * Alinhamento/Máscaras nos relatórios
  * Cálculos/Qual o momento. Exemplo: Qtde x Preço Unitário – Descontos = Preço total
  * Alinhamento de informações no Atencao
  * Quando enviar e-mails dentro das rotinas

## BIBLIOTECA HPRO

A biblioteca HPro é composta de diversas units sendo que as mais importantes são as seguintes:

  * **HProFunc.pas** – Funções básicas de utilização genérica
  * **HProDB.pas** – Funções de acesso e controle de dados
  * **HProWin.pas** – Funções de caráter visual atrelado aos componentes do Windows
  * **HProConst.pas** – Utilizada para armazenar as variáveis “públicas” do sistema

**Resumo das funções mais importantes encontradas na unit HProFunc.pas.**

  * **Acesso:** Controla direitos de acesso de processos
  * **Atencao:** Mensagens para o usuário e confirmação do usuário
  * **Beep:** Emite um bip padrão
  * **Conversão: ctod:** Converte um texto em data
  * **Conversão: DateToSql:** Converte uma data para o padrão SQL (yyyy-mm-dd) (idem a DtoSql)
  * **Conversão: dtoc:** Converte uma data em um texto no formato dd/mm/yyyy
  * **DBGridColor:** Para colorir uma linha de um grid de acordo com uma condição
  * **Empty:** Retorna True se a string ou Data ou Número estiverem vazios
  * **Fill:** Para formatação durante a geração de arquivos (lay-outs)
  * **FindOrder:** NÃO UTILIZAR
  * **FirstDay:** Retorna a data do primeiro dia do mês de uma data parâmetro
  * **FloatControl:** Permite consultar um campo memo em um painel desabilitado
  * **FloatToSql:** Converte um valor para o formato SQL (com ponto como separador decimal)
  * **GetPublicPar:** Retorna o conteúdo de um parâmetro de sistema (sempre string)
  * **Hton:** Converte uma string: hh:mm em número para cálculo com horas
  * **IsAcesso:** Verifica se o usuário tem direito de processo (ou interno)
  * **IsCGC ou IsCNPJ:** Retorna True se o CNPJ passado estiver correto
  * **IsCPF:** Retorna True se o CPF passado estiver correto
  * **IsContido:** Retorna true se o parâmetro está contido em um conjunto
  * **LastDay:** Retorna a data do último dia do parâmetro data passado
  * **Ntoh:** Usado junto com hton para cálculo com horas
  * **OnlyNumber:** Retorna SOMENTE os números: Ex; 12/1233-44 retornará 12123344
  * **Parse:** Extrai um texto baseado em caracteres separadores
  * **PerformSQL:** Funções para execução rápida de SQL
  * **Replicate:** Para repetir um caracter n vezes
  * **ShowWait/HideWait:** Exibe/Esconde janela de processamento para o usuário
  * **Spaces:** Gera uma sequência com n espaços
  * **StrTran:** Substitui um trecho do texto por outro
  * **Transform:** Insere máscara em um texto puro
  * **Trunca:** Arredonda valores
  * **UserQuery**
  * **Valor:** Obtém o valor com casas decimais de um texto
  * **ValorInt:** Obtém o valor inteiro de um texto

## Componente THProTable

Devido à uma série de novos recursos que são pertinentes à HPro Informática, foi criado um componente descendente da tabela do DBISAM (TDBISAMTable). Este componente se chama HproTable e além de oferecer as propriedades, métodos e eventos do DBISAM, o mesmo oferece diversos recursos adicionais.

### Obtendo informações de campos:

Normalmente o Delphi utiliza-se de um método padrão para obter informações de uma tabela. Este método é o FieldByName mas o seu uso acarreta um texto extremamente longo.

Ao invés de usar
`Tabela.FieldByName(‘campo’).AsString`
Utilizamos
`Tabela.Gets(‘campo’);`

  * **Geti** (para obter inteiros)
  * **Getd** (para obter datas)
  * **Getf** (para valores com casas decimais com tipo de dados BCD ou Float)
  * **Gets** (para campos string ou memo )
  * **Getk** (para representar os valores já com as máscaras).

Exemplo: `Tabela.Geti(‘Cod’)` equivalente a `Tabela.FieldByName(‘Cod’).AsInteger`,
ou ainda `Tabela.Getd(‘Emi’)` equivalente à `Tabela.FieldByname(‘Emi’).AsDateTime`.

### Atribuído valores para campos:

Analogamente ao método GET foram criados vários métodos PUT seguindo os mesmos critérios.

Ao invés de usar
`Tabela.FieldByName(‘Campo’).AsInteger := nValor`
Utilizamos
`Tabela.Puti(‘Campo’,nValor).`

  * **Puti** (para atribuir inteiros)
  * **Putd** (para atribuir datas)
  * **Putf** (para valores com casas decimais com tipo de dados BCD ou Float)
  * **Puts** (para campos string ou memo )
  * **Putk** (para representar os valores já com as máscaras).

### Propriedades importantes:

  * AutoPrimaryKey: True/False\*
  * NewKey
  * NewKeyInt

## Componente THProQuery

Identicamente ao componente THProTable, foi criado um componente descendente do DBISAM (TDBISAMQuery).

Os mesmos métodos Get e Put estão disponíveis para o componente THProQuery.

### Propriedades importantes:

  * RequestLive
  * ResultIsLive

### LiveResult and Canned Result:

Quando utilizamos queries, existem algumas considerações que devem ficar bem claras para o desenvolvedor. Primeiramente precisamos entender o que é LiveResult. Esta propriedade somente estará disponível APÓS a execução da query sendo que LiveResult retornará se o DBISAM conseguiu obter o acesso ou não às tabelas usando índices e filtros internos e NÃO foi necessário gerar uma tabela temporária para gerar o resultado. Existem casos em que não é possível utilizar filtros na leitura das tabelas então o DBISAM cria uma tabela temporária para satisfazer as condições do WHERE e do ORDER BY, neste último caso o resultado de LiveResult é False. Quando o resultado de LiveResult é False, então dizemos que o resultado é Canned (enlatado). A principal diferença entre eles é que QUALQUER alteração em uma query com resultado Canned NÃO será refletida na tabela original. Existe uma propriedade da query que é RequestLive. Esta propriedade controla como o DBISAM tentará acessar os dados. Se RequestLive for True então o DBISAM tentará acessar diretamente as tabelas utilizando filtros internos, porém o mesmo pode não ser possível então o resultado será Canned. Se RequestLive for False então mesmo que exista a opção de se acessar diretamente as tabelas, o DBISAM criará uma tabela temporária. Quando o resultado é composto de mais de uma tabela o resultado será SEMPRE canned, isto é, SEMPRE será gerada uma tabela temporária para armazenar o resultado.

## Componente THProView

Os componentes da aba Edulib também foram feitos para facilitar o processo de desenvolvimento e o mais importante (e mais utilizado) é o componente THProView.

  * OnActivate
  * OnButton
  * OnCalcFields
  * OnEmpty
  * OnSelect

**Exemplo de chamada:**

```delphi
procedure VGru(hv: THProView);
begin
    with hv do begin
        Title := 'Consulta grupos de materiais';

        // Código utilizado quando o usuário digita o código ao invés de selecionar da lista
        SqlValid := 'select des from hgru where cod=:1 and sit=''Ativo''';

        // Código utilizado APENAS quando a tabela NÃO será editada (utilizado em históricos)
        SqlCaption := 'select des from hgru where cod=:1';

        // Código utilizado para EXIBIÇÃO dos dados
        SqlShow := 'select cod, des from hgru where sit=''Ativo'' order by des nocase';

        Query.MainTable := D.TGru;
        Query.Clear;
        Query.Add('Cod;Código');
        Query.Add('Des;Descrição');
    end;
end;
```

O evento OnActivate é utilizado para chamar/ativar o View.
O evento OnSelect é disparado quando o usuário escolhe um item do grid ou quando o código é digitado diretamente.

## Procedimento I – Impressão com o componente TImpressora

Existem 2 (dois) tipos:

  * **Automática:** Utilizada na maioria das vezes

**Exemplo:**

```delphi
// Define-se o título do relatório
Imp.Title := ‘Título do relatório’;

// Orienta o componente de impressão a imprimir o que está no grid vinculado a tabela
Imp.Columns.Assign(Tabela.PrintFields);

// Define qual ou quais colunas deverão ser totalizadas (propriedade opcional)
Imp.SumColumns := ‘Tot;Jur’;  // Para totalizar os campos Tot e Jur

// Inicia o processo de impressão solicitando a escolha da impressora
Imp.Start;
```

  * **Manual:** Devem ser utilizados os eventos OnHeader, OnDetail e OnStop

      * **OnHeader:** Utilizado para imprimir o cabeçalho do relatório
      * **OnDetail:** Utilizado para imprimir o corpo do retatório
      * **OnStop:** Utilizado para finalizar imprimindo observações, totais, etc.

<!-- end list -->

```delphi
// Evento OnHeader
with Imp do begin
    Say(Row+1,10,'Número....: '+D.TPecNum.DisplayText+'  -  Data: '+EDat.Text);
    Say(Row+1,10,'Comprador.: '+ECom.Text+' - '+CCom.Text);
    Say(Row+1,10,'Fornecedor: '+EFor.Text+' - '+CFor.Text);
    Say(Row+1,10,'Contato...: '+ECon.Text);
    Say(Row+1,10,'Previsão de entrega..: '+EPre.Text);
    Say(Row+1,10,'Condição de Pagamento: '+EPag.Text);
    Say(Row+1,10,'Vencimentos..........: ');
    Line;
    Say(Row+1, 1,'Seq');
    Say(Row  , 5,'Produto');
    Say(Row  ,55,'Quantidade');
    Say(Row  ,66,'P.Unitário');
    Say(Row  ,77,'Desconto');
    Say(Row  ,89,'P.Total');
    Line;
end;

// Evento OnDetail
with Imp do begin
    Say(Row+1, 1,format('%.3d',[nSeq]));
    Say(Row  , 5,format('%8.4n',[TIcoPro.Value]));
    Say(Row  ,14,TIcoPDes.DisplayText);
    Say(Row  ,56,format('%9.3n',[TIcoQtd.Value]));
    Say(Row  ,66,format('%10.3n',[TIcoPre.Value]));
    Say(Row  ,77,format('%8.2n',[TIcoDes.Value]));
    Say(Row  ,86,format('%10.2n',[TIcoTot.Value]));
end;

// Evento OnStop
with Imp do begin
    Say(Row+2,73,'     Total =>');
    Say(Row  ,86,format('%10.2n',[GetTotal('Tot')]));

    // Observações (se houver)
    if D.TPec.NotEmpty(‘Obs’) then begin
        Say(Row+2,10,'Observações: ');
        DefMemoField(D.TPecObs, 70);
        for nI := 0 to MemoCount-1 do begin
            if nI = 0 then begin
                Say(Row,Col,MemoLine(nI));
            end else begin
                Say(Row+1,10,'             '+MemoLine(nI));
            end;
        end;
    end;
    Line;
end;
```

## Procedimento 2 – Totalização de valores através do botão “Totalizar”

Existem 2 (dois) tipos de método para totalizar colunas:

  * **Automático – Maioria das vezes**

<!-- end list -->

```delphi
// Para totalizar um campo
TotalizarDados(Dataset,'Tot');

// Para totalizar um campo (mudando o termo “Total” padrão para “Valor Total”)
TotalizarDados(Dataset,'Tot;Valor Total');

// Para totalizar mais de um campo
TotalizarDados(TPag,'Val;Valores;Jur;Juros;Dsc;Descontos');

// Para totalizar mais de um campo com agrupamento por um outro campo
TotalizarDados(TPag,'Val;Valores;Jur;Juros;Dsc;Descontos','Sta');
```

  * **Manual:** Para realização de totalização personalizada com cálculos diferentes, média ponderada, etc. Deve-se utilizar do método descrito abaixo:

<!-- end list -->

```delphi
procedure TForm1.Totalizar(Sender: TObject);
var nTot: Real;
    nQtd: Integer;
begin
    nTot := 0;
    nQtd := 0;
    TMov.SavePos; // Salva a posição do ponteiro de registro e desabilita vínculos
    try
        TMov.First;
        while not TMov.Eof do begin
            nQtd := nQtd + 1;
            nTot := nTot + TMov.Getf('Tot');
            TMov.Next;
        end;
    finally
        TMov.RestorePos; // Retorna a posição do ponteiro de registo e habilita vínculos
    end;
    beep;
    atencao('### TOTAL ###' +
            ';Quantidade: ' + IntToStr(nQtd) +
            ';Total.....: ' + format(‘%12.2n’,[nTot]);
    CheckButtons;
end;
```

## Procedimento 3 – Arredondamento de cálculos

Em todas as situações onde existam cálculos, precisamos arredondar valor APENAS no final do processo. Tanto para exibição, impressão ou mesmo para armazenar no banco de dados. Para isto, deve-se utilizar a função Trunca.

**Exemplo:**

```delphi
Trunca(nVal,2);      // Para arredondar com 2 casas decimais
Trunca(nVal,3);      // Para arredondar com 3 casas decimais
```

## Procedimento 4 – Utilização de tabelas na memória

Normalmente criadas no evento OnCreate do formulário. Porém existem casos onde a mesma é criada dentro do botão processar.

```delphi
// Definição dos campos
with TMem.FieldDefs do begin
  Clear;
  Add('cod',ftInteger,0,False);
  Add('dat',ftDate,0,False);
  Add('nom',ftString,15,False);   // Tamanho do campo 15
  Add('val',ftBCD,4,False);       // Campo BCD sempre deve ter tamanho 4
end;

// Definição dos índices
with TMem.IndexDefs do begin
  Clear;
  Add('cod','cod',[ixPrimary]);         // Chave primária
  Add('dat','dat;cod',[ixDescending]);    // Chave descendente
  Add('nom','nom',[ixCaseInsensitive]);   // Chave case insensitive
end;

// Cria a tabela (se não existir).
TMem.OpenMemory;
```

Após a criação da tabela todos os outros métodos de uma tabela física (no disco) podem ser utilizadados. A única diferença é que esta tabela após fechada não é salva em lugar nenhum.

## Procedimento 5 – Exemplo de controle de saldo em estoque com movimentação

```delphi
procedure ProcessaEstoque;
var nRec: Integer;
    cKey: String;
    nSal: Real;
    nMed: Real;
    nOld: Real;
    nNew: Real;
begin
    cKey := D.TMov.Gets('Pro');
    nRec := D.TMov.Recno;
    try
        D.TMov.Prior;
        if (D.TMov.Bof) or (D.TMov.Gets('Pro') <> cKey) then begin
            if not D.TMov.Bof then begin
                D.TMov.Next;
            end;
            nSal := 0;
            nMed := 0;
        end else begin
            nSal := D.TMov.Getf('San');
            if D.TMov.Gets('Tim',1) = 'E' then begin
                nSal := nSal + D.TMov.Getf('Qtd');
            end else begin
                nSal := nSal - D.TMov.Getf('Qtd');
            end;
            nMed := D.TMov.Getf('Med');
            D.TMov.Next;
        end;

        while (not D.TMov.Eof) and (D.TMov.Gets('Pro') = cKey) do begin
            D.TMov.Edit;
            D.TMov.Putf('San',nSal);
            if D.TMov.Gets('Tim',1) = 'E' then begin
                // Atualiza preço médio do produto se o tipo de movto for ECO
                if D.TMov.Gets('Tim') = 'ECO' then begin
                    if (nMed <> 0) and D.TMov.NotEmpty('San') then begin
                        if (D.TMov.Getf('San') + D.TMov.Getf('Qtd')) > 0 then begin
                            nOld := nMed * D.TMov.Getf('San');
                            nNew := D.TMov.Getf('Pre') * D.TMov.Getf('Qtd');
                            nMed := (nOld + nNew)/(D.TMov.Getf('San') + D.TMov.Getf('Qtd'));
                        end;
                        nMed := trunca(nMed,3);
                    end else begin
                        nMed := D.TMov.Getf('Pre');
                    end;
                end else if D.TMov.Gets('Tim') = 'EIN' then begin
                    nMed := D.TMov.Getf('Pre');
                end;
                nSal := nSal + D.TMov.Getf('Qtd');
            end else begin
                nSal := nSal - D.TMov.Getf('Qtd');
            end;
            D.TMov.Putf('Med', nMed);
            D.TMov.Post;
            D.TMov.Next;
        end;

    finally
        D.TMov.Recno := nRec;
    end;

    if D.TSal.FindKey([D.TMov.Gets('Pro')]) then begin
        D.TSal.Edit;
        D.TSal.Putf('Sal',nSal);
        D.TSal.Post;
    end else begin
        D.TSal.Append;
        D.TSal.Puts('Pro', D.TMov.Gets('Pro'));
        D.TSal.Putf('Sal', nSal);
        D.TSal.Post;
    end;
end;
```

## PADRONIZAÇÃO DOS NOMES DOS FORMULÁRIOS (TELAS)

Deverão começar com a letra F seguido de 3 letras com o significado do módulo em questão além de uma numeração sequencial com até 2 dígitos.

**Exemplo:** FCLI01, FCLI02, FEST01, FMOV01, etc.

## PADRONIZAÇÃO DOS NOMES DAS TABELAS

Todas as tabelas do sistema deverão iniciar com a letra H seguida de um complemento de 3 letras que representam o que estará contido nesta tabela.

**Exemplo:** HCLI tabela de clientes, HFOR tabela de fornecedores, HPRO tabela de produtos e assim por diante.

Excepcionalmente as tabelas poderão conter mais do que 4 letras mas isto deverá ser evitado. Por sua vez, dentro do Delphi teremos os componentes equivalentes para acesso à estas tabelas. Sendo assim, TCLI para acessar a tabela HCLI, TFOR par acessar a tabela HFOR e assim por diante. Ver anexo I para as padronizações.

| Tabela | Descrição | Tabela | Descrição |
| :--- | :--- | :--- | :--- |
| HAPO | Controle de apontamentos de horários | HORC | Cadastro de orçamentos |
| HATI | Cadastro de ramos de atividades | HOSE | Cadastro de ordens de serviço |
| HBAL | Vendas balcão | HPAG | Controle de contas à pagar |
| HBAN | Cadastro de bancos | HPEC | Cadastro de pedidos de compra |
| HCAI | Movimentos do controle de caixa | HPEV | Cadastro de pedidos de venda |
| HCBA | Cadastro de contas bancárias | HPRO | Cadastro de produtos |
| HCFI | Cadastro de classificações financeiras (pagar/receber) | HREB | Cadastro de recibos |
| HCFO | Cadastro de CFOPs (para notas fiscais) | HREC | Controle de contas à receber |
| HCHE | Cadastro de cheques | HREF | Controle de referência de movimentos do caixa |
| HCID | Cadastro de cidades | HREG | Cadastro de regiões de venda |
| HCLC | Cadastro de contatos dos clientes | HREP | Cadastro de representantes |
| HCLF | Cadastro de classificações fiscais | HREQ | Cadastro de requisições de compra |
| HCLI | Cadastro de clientes | HSAB | Cadastro de saldos nas contas bancárias |
| HCOC | Controle de contas correntes | HSAL | Cadastro de saldos de estoque |
| HCOT | Cadastro de cotações para compra | HSER | Cadastro de serviços |
| HDEP | Cadastro de departamentos | HTIM | Cadastro de tipos de movimentos de estoque |
| HDES | Cadastro de despesas | HTRA | Cadastro de transportadoras |
| HDUP | Cadastro de duplicatas | HVEN | Cadastro de vendedores |
| HECO | Controle de entregas de compras | | |
| HEMP | Cadastro de empresas | | |
| HUFS | Cadastro de estados | | |
| HEVE | Controle de entregas de vendas | | |
| HFER | Cadastro de feriados | | |
| HFOC | Cadastro de contatos dos fornecedores | | |
| HFOP | Cadastro de formas de pagamento | | |
| HFOR | Cadastro de fornecedores | | |
| HFUN | Cadastro de funcionários | | |
| HGRU | Cadastro de grupos de produtos | | |
| HICO | Cadastro de itens de compra | | |
| HINE | Cadastro de itens da nota fiscal de entrada | | |
| HINO | Cadastro de itens da nofa fiscal de saída | | |
| HITC | Cadastro de itens das cotações de compra | | |
| HITO | Cadastro de itens dos orçamentos de venda | | |
| HIVE | Cadastro de itens dos pedidos de venda | | |
| HLOT | Cadastro de lotes | | |
| HMAT | Cadastro de materiais | | |
| HMBA | Movimentos bancários (lançamentos) | | |
| HMOV | Movimentos de estoque (lançamentos) | | |
| HNFE | Cadastro de notas fiscais de entrada | | |
| HNOT | Cadastro de notas fiscais de saída | | |

## PADRONIZAÇÃO DOS NOMES DOS CAMPOS DAS TABELAS

Os nomes de campos deverão ter por padrão 3 letras que indicarão o que está contido no campo em questão.

**Exemplo:** RAZ (razão social), END (endereço), NOM (nome), NUM (número), COD (código) e assim por diante. Como no caso das tabelas, apenas em casos excepcionais esta regra poderá mudar (como no caso de um campo para armazenar RG). O objetivo de se utilizar poucas letras na descrição dos campos é tornar o código prático e limpo. Ver anexo II com os padrões.

**Observação:** Nomes de índices seguirão o mesmo critério adotado para os nomes de campos.

| Campo | Tipo | Tamanho | Descrição |
| :--- | :--- | :--- | :--- |
| BAI | S | 30 | Bairro |
| CEP | S | 8 | CEP |
| CID | S | 34 | Cidade |
| COD | I | | Código |
| DAE | D | | Data de entrada (para notas fiscais de entrada) |
| DAP | D | | Data de pagamento |
| DAR | D | | Data de recebimento |
| DES | S | 40 | Descrição (produtos, serviços, tipos, etc) |
| DOC | S | 15 | Documento |
| DOI | S | 15 | Documento (Interno) para integrações – Campo não disponível para o usuário |
| EMI | D | | Data de emissão |
| ENT | D | | Data da entrega |
| FAN | S | 40 | Nome fantasia |
| HIS | S | 60 | Histórico |
| NUM | S | 8 | Normalmente usado para representar números de pedidos, lotes, etc. Tem o formato AA/999999. |
| PCU | BCD | | Preço de custo |
| PRE | BCD | | Preço unitário |
| PVE | BCD | | Preço de venda |
| QTD | BCD | | Quantidade (pode ser inteiro ou decimal variando o número de decimais conforme cada cliente). |
| RAZ | S | 40 | Razão Social |
| SAL | BCD | | Segue o mesmo critério do campo QTD (Quantidade) |
| TOT | BCD | | Preço total. Normalmente é o resultado de PRE \* QTD |
| VAR | BCD | | Valor recebido |
| VAP | BCD | | Valor pago |
| VAL | BCD | | Valor |
| VEN | D | | Vencimento |

**IMPOSTOS**

| Campo | Tipo | Tamanho | Descrição |
| :--- | :--- | :--- | :--- |
| ICMCST | C3/C4 | | Situação tributária de ICMS (4 casas para empresas do SIMPLES) |
| ICMRED | BCD | | Redução de Base de cálculo de ICMS |
| ICMBAS | BCD | | Base de Cálculo |
| ICMALI | BCD | | Alíquota de ICMS |
| ICMVAL | BCD | | Valor do ICMS |
| IPICST | C2 | | Situação tributária do IPI |
| IPIBAS | BCD | | Base de cálculo de IPI |
| IPIALI | BCD | | Alíquota de IPI |
| IPIVAL | BCD | | Valor do IPI |
| PISCST | C2 | | Situação tributária de PIS |
| PISBAS | BCD | | Base de cálculo do PIS |
| PISALI | BCD | | Alíquota do PIS |
| PISVAL | BCD | | Valor do PIS |
| COFCST | C2 | | Situação tributária do COFINS |
| COFBAS | BCD | | Base de cálculo do COFINS |
| COFALI | BCD | | Alíquota do COFINS |
| COFVAL | BCD | | Valor do COFINS |
| ISTBAS | BCD | | Base de cálculo ICMS-ST |
| ISTVAL | BCD | | Valor do ICMS-ST |

## PADRONIZAÇÃO DOS NOMES DAS VARIÁVEIS

Todos os nomes de variáveis que representam valores numéricos (inteiro, float) devem ser precedidos da letra ‘n’ minúscula seguido do nome da variável iniciando com uma letra maiúscula. Para representar datas deve-se preceder o nome com ‘d’. Para representar strings ou memo deve-se preceder o nome com ‘c’.

**Exemplo:** nVal (campo com algum valor numérico), dEmi (campo contendo uma data de emissão, cNom (string contendo um nome).

As demais variáveis utilizadas para guardar objetos (como TStringList) não seguem um padrão, ficando a critério do programador a regra para utilizá-las.

Utilizar o mesmo conceito dos campos adicionando o prefixo (d, n, c ou x):

  * **d** = Para variáveis do tipo data
  * **n** = Para variáveis numéricas (inteiro ou float)
  * **c** = Para variáveis do tipo string (ou memo)
  * **b** = Para variáveis do boolean (True ou False)
  * **x** = Para objetos de forma geral

**Exemplos:**

  * dEmi = Data de emissão
  * nTot = Valor total

**CONTADORES**

Para contadores (for, while, etc.) utilizar (nI, nJ, nK).

## TREINAMENTO PRÁTICO

1.  **Criar novo projeto GenAplic**
2.  **Novas tabelas**
      * **Tabela HCLI: Cadastro de clientes**
          * Campos:
              * COD Código (I)
              * RAZ Razão Social (S 40)
              * EST Estado (S 2)
              * CID Cidade (I) - Integridade HMUI.COD
              * NAS Nascimento (D)
      * **Tabela HMUI: Cadastro de cidades**
          * Campos:
              * COD Código (I)
              * DES Descrição (S 40)
3.  **Cadastro de cliente**
      * **GRID**
          * \-\> Código
          * \-\> Descrição
          * \-\> Estado
          * \-\> Cidade - Calculado
      * **MODAL**
          * \-\> Código
          * \-\> Descrição
          * \-\> Estado
          * \-\> Cidade (HProView)
4.  **MDI - Cidades**
      * **GRID**
          * \-\> Código
          * \-\> Descrição
      * **MODAL**
          * \-\> Código
          * \-\> Descrição
5.  **Consulta**
      * **FILTROS**
          * \-\> Cidade
          * \-\> Período (Data de nascimento)
      * **GRID**
          * \-\> Código
          * \-\> Razão Social
          * \-\> Estado
          * \-\> Cidade
          * \-\> Nascimento

## RECURSOS AVANÇADOS

*Devem ser apresentados APÓS a apresentação do projeto final*

  * Try..finally e try..except
  * SavePos/RestorePos
  * OpenTemp/CloseTemp
  * BeginTemp/OpenTemp/CloseTemp
  * AdjustButtons
  * Trabalhar com 2 grids sincronizados
  * Programação antiga x Programação nova
  * Uso de record e array
  * Editar campos diretamente no grid
  * Auditoria
  * Transação restrita x Transação normal
  * Direitos de acesso
  * Hint dos menus para direitos de acesso
  * RPServer (funcionamento)
  * Métodos: IsEmpty, NotEmpty, GetsContido,
  * AtencaoErro,
  * Puts(\<campo\>,\<valor\>,\<valor\_anterior\>)
  * Hproupd.ant e Hproupd.dep
  * Arquivos: TXT, CSV, XML, JSON
  * Leitura e geração de arquivos texto
  * Multithread
  * Parâmetro do Sistema
  * Ativar o direito de menu ao criar um menu novo
  * Atualizando o pacote HPro as segundas - feiras
  * Botões com duas linhas
  * Consulta avançada
  * Utilização do Mark
  * Utilização do ChangeControl

## EVITANDO AS ARMADILHAS

  * Alterar a chave do índice atual em uma situação de loop
  * Enviar e-mail durante uma operação de transação no banco de dados
  * Cuidados com o escopo das variáveis das rotinas
  * Tempo da transação x interação com usuário
  * Afiar o machado durante 30 minutos x usar o machado durante 1 minuto
  * Pensar nas exceções (e se…)
  * Ponteiro de registros das tabelas abertas nos diversos formulários
  * Criar objetos x destruir objetos (Free x FreeAndNil)
  * Access Violation (não deve ser ignorado e sim deve ser investigado)
  * Pensar como Usuário
  * FindKey([],True)
  * Chave primária "sempre" com campos obrigatórios

## OBRIGAÇÕES FISCAIS E CONTÁBEIS

  * NF-e
  * NFS-e
  * MDF-e
  * CT-e
  * SPEDFISCAL ou EFD ICMS
  * SPEDCONTRIBUIÇÕES OU EFD PIS/COFINS
  * ECD (Escrituração contábil digital)
  * ECF (Escrituração contábil fiscal)
  * REINF
  * AGROTIS
  * SAT
  * Contabilidade
  * Livros fiscais
  * Folha de pagamento