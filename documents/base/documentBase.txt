Estrutura de um projeto

A estrutura de um projeto em Delphi é composta pelos arquivos DPR (arquivo de projeto Delphi), PAS (arquivos-fonte com código em pascal - conhecido também como unit), DFM (arquivos-fonte que representam o formulário associado ao arquivo PAS), DCU (código-objeto gerado a partir dos arquivos PAS e DFM) e RES (arquivo de recursos do projeto - onde é armazenado o ícone do projeto, exemplo).

Processo de compilação = DPR + RES + PAS + DFM = DCU
Processo de link-edição = DCU + (arquivos da biblioteca do Delphi) = EXE

Nota: Todos os arquivos iniciados com o sinal ~ (til) são arquivos de backup e podem ser apagados. Os demais arquivos geralmente não são relevantes, mas é recomendado não excluir nenhum arquivo contido na pasta do projeto.

Tipos de Dados em Delphi

O Delphi oferece uma vasta lista de tipos de dados. Esses tipos de dados podem ser divididos em categorias. Para maiores informações sobre a representação desses tipos de dados, recomenda-se buscar a documentação da versão do Delphi com a qual se está trabalhando. As versões mais modernas do Delphi oferecem as seguintes categorias.

Nota sobre a convenção HPro: Tipos prefixados com 'HPro-' indicam tipos de dados padrão ou de uso comum na HPro.

CATEGORIA: NÚMEROS INTEIROS
oByte
oShortInt
oWord
oSmallInt
oCardinal
oLongWord
oFixedUInt
HPro-oInteger
oLongInt
oFixedInt
oUInt64
oInt64
oNativeUInt
oNativeInt

CATEGORIA: NÚMEROS COM PONTO-FLUTUANTE
oSingle
oDouble
oExtended
HPro-oCurrency
HPro-oReal

CATEGORIA: STRINGS E CARACTERES
oAnsiChar
oChar
oWideChar
oAnsiString
oRawByteString
oUnicodeString
HPro-oString
oShortString
oWideString

CATEGORIA: ARQUIVOS
oFile
oTextFile, Text

CATEGORIA: DADOS LÓGICOS (BOOLEANOS)
HPro-oBoolean
oByteBool
oWordBool
oLongBool

CATEGORIA: OUTROS TIPOS DE DADOS
HPro-oArray
HPro-oRecord
oVariant
oPointer

INFORMAÇÕES TÉCNICAS DO BANCO DE DADOS DBISAM

ESTRUTURA DE ARQUIVOS

As tabelas do banco de dados são armazenadas em arquivos com as seguintes extensões:

DAT
Armazena os dados principais da tabela.

IDX
Armazena todos os índices da tabela em um único arquivo.

BLB
Armazena o conteúdo de campos do tipo "memo". Este arquivo só existe se a tabela possuir campos memo.

Convenção para ElevateDB
Para o banco de dados ElevateDB, as mesmas extensões são utilizadas com o prefixo "e": eDat, eBlb, eIdx.

TIPOS DE DADOS PRINCIPAIS

Os tipos de dados utilizados pelo DBISAM são:

Integer
Para representar números inteiros.

BCD
Para representar números com precisão de até 4 casas decimais. É ideal para valores monetários.

Float
Para representar números com um grande número de casas decimais.

Aviso sobre o tipo Float: Deve ser evitado em cálculos que exigem alta precisão, pois um valor exibido como 2,00 pode estar armazenado como 1,9999999999, o que pode levar a erros de arredondamento.

Date
Para representar datas.

String
Para representar campos de texto com um tamanho fixo de caracteres.

Memo
Para representar campos de texto com tamanho variável, sem um limite de caracteres predefinido.

PROCESSO DE TRANSAÇÕES NO BANCO DE DADOS

DEFINIÇÃO DE TRANSAÇÃO
Uma transação é um processo que garante a execução completa e segura de um conjunto de atualizações em tabelas. O objetivo é assegurar a integridade dos dados: ou todas as operações são concluídas com sucesso, ou nenhuma delas é permanentemente salva.

PASSOS PARA EXECUTAR UMA TRANSAÇÃO

Passo 1: Iniciar a Transação
O início do conjunto de operações é definido pelo comando D.Transaction.

Passo 2: Processar as Atualizações
Após iniciar a transação, todas as operações necessárias de atualização nas tabelas são executadas.

Passo 3: Finalizar e Salvar (Commit)
Ao final do processamento, o comando D.Commit é usado para finalizar a transação e salvar permanentemente todas as alterações no banco de dados.

TRATAMENTO DE ERROS E CANCELAMENTO (ROLLBACK)

Se ocorrer qualquer erro ou interrupção durante o processamento (Passo 2), o banco de dados executa um ROLLBACK automaticamente.

O ROLLBACK cancela todas as alterações feitas desde o início da transação (D.Transaction).

Como resultado, o banco de dados retorna exatamente ao estado em que se encontrava antes da transação começar, garantindo que nenhuma atualização parcial ou incorreta seja gravada.

CONTROLE DE CONCORRÊNCIA DE ACESSO AOS DADOS

DEFINIÇÃO DE CONCORRÊNCIA
Em sistemas modernos, vários usuários acessam e modificam dados simultaneamente. A concorrência ocorre quando dois ou more usuários tentam realizar operações no mesmo conjunto de dados ao mesmo tempo. O sistema precisa gerenciar essas situações para manter a integridade dos dados.

CENÁRIO 1: INCLUSÃO SIMULTÂNEA DE NOVOS REGISTROS

Problema Comum:
Dois ou mais usuários tentam inserir um novo registro no mesmo módulo ao mesmo tempo, o que pode levar a um erro de duplicidade de chave primária.

Solução HPro com HPROTABLE:
Para evitar o erro de chave duplicada e tornar o processo transparente para os usuários, o componente HPROTABLE pode gerar a próxima chave primária disponível automaticamente.

Implementação da Solução:
Para ativar este comportamento, defina a propriedade Tabela.AutoPrimaryKey := True imediatamente antes de chamar o método Tabela.Post.

Exemplo Prático:
Quatro usuários tentam criar um novo cliente, e o sistema sugere o código "1" para todos.
Se AutoPrimaryKey for False, apenas o primeiro usuário terá sucesso; os outros receberão um erro.
Se AutoPrimaryKey for True, todos os quatro usuários conseguirão criar o registro, e o sistema irá gerar chaves sequenciais para cada um (ex: 1, 2, 3, 4).

CENÁRIO 2: ALTERAÇÃO OU EXCLUSÃO SIMULTÂNEA DO MESMO REGISTRO

Problema Comum:
Dois ou mais usuários tentam editar ou excluir o mesmo registro existente ao mesmo tempo.

Comportamento do Sistema:
O sistema opera com um bloqueio otimista. O primeiro usuário que salvar a alteração ou a exclusão terá sucesso.

Os usuários seguintes que tentarem salvar suas modificações no mesmo registro receberão a mensagem de erro: "Registro alterado ou excluído por outro usuário".
	
PADRÃO DE VALIDAÇÃO DE CAMPOS E FORMULÁRIOS

DIRETRIZ PRINCIPAL DE VALIDAÇÃO

A validação dos dados inseridos pelo usuário deve ocorrer em um único momento centralizado, preferencialmente ao final do processo de digitação.

MOMENTO DA VALIDAÇÃO

O evento ideal para executar todas as validações de campos e formulários é o clique no botão de confirmação, como "Gravar" ou "OK".

LÓGICA DE IMPLEMENTAÇÃO

Permita que o usuário preencha todos os campos do formulário livremente, sem interrupções ou validações durante a digitação campo a campo.

Centralize todo o código de validação para ser executado somente após o usuário sinalizar a conclusão da entrada de dados (clicando em "Gravar" ou "OK").

Neste momento, o sistema tem controle total sobre o estado do formulário e pode executar todas as checagens de uma única vez, de forma sequencial e controlada, antes de persistir os dados.

JUSTIFICATIVA DA ABORDAGEM

Validar campos durante a digitação em ambientes gráficos (GUI) é complexo e propenso a falhas devido à interação não linear do usuário (uso do mouse para mudar o foco, por exemplo). A validação centralizada no final do processo é mais robusta, mais simples de manter e oferece uma experiência de usuário mais fluida.
	
INTEGRIDADE REFERENCIAL NO BANCO DE DADOS

DEFINIÇÃO
A integridade referencial é uma característica do banco de dados que impede a exclusão de um registro que está sendo referenciado ou utilizado por registros em outras tabelas. Seu objetivo é garantir a consistência dos dados, evitando que registros fiquem "órfãos".

Exemplos de proteção:
Evita a exclusão de um cliente que já possui notas fiscais emitidas.
Evita a exclusão de um produto que possui movimentação de estoque.

REGRA DE IMPLEMENTAÇÃO
Para habilitar a integridade referencial, é mandatório definir as associações (relacionamentos) entre os campos das tabelas durante a modelagem do banco de dados.
Por exemplo, o campo de produto na tabela de "itens da nota fiscal" deve ser configurado para referenciar a tabela de "cadastro de produto".

COMPORTAMENTO DO SISTEMA EM UMA EXCLUSÃO
Quando um usuário tenta excluir um registro, o sistema executa a seguinte verificação:

O sistema analisa se o ID daquele registro existe em alguma outra tabela com a qual ele tem uma associação definida.

Se um ou mais vínculos forem encontrados, a exclusão é bloqueada.

Se nenhum vínculo for encontrado, a exclusão é permitida.

MENSAGEM AO USUÁRIO
No caso de uma exclusão bloqueada, o sistema deve emitir um aviso claro informando o motivo.
Exemplo de mensagem: "O registro NÃO poderá ser excluído devido ao fato de existir vínculos com outras tabelas."
	
CONTROLE DE CAMPOS OBRIGATÓRIOS

REGRA PREFERENCIAL: DEFINIÇÃO NO BANCO DE DADOS

A maneira primária e recomendada de definir campos como obrigatórios é diretamente na estrutura do banco de dados, através do Genfiles.

Nesta abordagem, o controle de preenchimento é realizado internamente pelo próprio DBISAM, garantindo a integridade dos dados no nível mais baixo.

SITUAÇÃO DE EXCEÇÃO: DEFINIÇÃO NO PROGRAMA

Em casos específicos, como a solicitação de tornar um campo obrigatório em uma tabela que já contém dados, o controle não deve ser feito no banco de dados.

Nestes cenários, a lógica de validação do campo obrigatório deve ser implementada diretamente no código do programa. A responsabilidade de verificar o preenchimento do campo antes de salvar o registro é inteiramente do programador.

AVISO CRÍTICO SOBRE A ALTERAÇÃO DE TABELAS EXISTENTES

Existe um risco significativo de perda de dados ao se definir um campo como obrigatório diretamente no banco de dados (via Genfiles) em uma tabela que já possui registros.

Se a tabela contiver registros onde este campo não esteja preenchido (valor nulo ou vazio), esses registros serão eliminados permanentemente pelo DBISAM durante o processo de alteração da estrutura.

Portanto, nunca altere um campo para obrigatório no banco de dados sem antes garantir que todos os registros existentes para aquele campo contenham um valor válido.
PROCESSO DE EXCLUSÃO DE REGISTROS NO DBISAM

COMPORTAMENTO PADRÃO DA EXCLUSÃO (EXCLUSÃO LÓGICA)

Por padrão, o DBISAM não remove fisicamente os registros do arquivo de dados ao executar uma exclusão.

Irreversibilidade: Uma vez que um registro é excluído, o DBISAM não oferece um método nativo para recuperá-lo.

Marcação Interna: O registro é marcado internamente como "excluído".

Reutilização de Espaço: O espaço ocupado por este registro marcado fica disponível e será reutilizado automaticamente pelo DBISAM na próxima operação de inclusão de um novo registro.

PROBLEMA POTENCIAL: TAMANHO DO ARQUIVO EM DISCO

Em cenários onde ocorrem muitas exclusões de registros e poucas inclusões, o espaço marcado como "excluído" não é reutilizado com frequência.

Como consequência, o tamanho físico do arquivo da tabela (extensão DAT) no disco não diminui, mesmo que a tabela contenha poucos registros ativos.

SOLUÇÃO PARA REDUÇÃO FÍSICA DO ARQUIVO (OTIMIZAÇÃO)
Para liberar o espaço em disco ocupado por registros excluídos e reduzir o tamanho físico do arquivo, existe um método específico.
Método: Tabela.OptimizeTable
Este método reescreve o arquivo da tabela, eliminando permanentemente os registros marcados como excluídos e compactando o arquivo.
Aviso de Uso:
O método Tabela.OptimizeTable é uma operação de manutenção pesada e raramente utilizada. Seu uso deve ser reservado para casos extremos, onde a redução do tamanho do arquivo em disco é estritamente necessária.
	
REGRAS DE USO DE ÍNDICES NO DBISAM
IMPORTÂNCIA DOS ÍNDICES
A performance do banco de dados DBISAM depende diretamente da existência de índices apropriados para as consultas. Processamentos sem os índices corretos resultarão em lentidão.
CRIAÇÃO DE ÍNDICES COMPOSTOS (MÚLTIPLOS CAMPOS)
Para criar um índice que abrange mais de um campo, utilize o caractere ponto e vírgula (;) como separador.
Exemplo de Sintaxe:
CLI;DAT
Neste exemplo, um único índice é criado para os campos CLI e DAT, com CLI sendo o primeiro campo e DAT o segundo.

REGRA CRÍTICA DE OTIMIZAÇÃO PARA CONSULTAS SQL
O otimizador de consultas SQL do DBISAM utiliza APENAS o primeiro campo de qualquer índice para acelerar uma pesquisa. Campos subsequentes em um índice composto não são considerados pelo otimizador de SQL.
EXEMPLO PRÁTICO DA REGRA DE OTIMIZAÇÃO
Considerando um índice definido como "CLI;DAT":
Cenário 1: Pesquisa Otimizada
Uma consulta SQL que utilize um filtro no campo CLI será otimizada pelo índice e executada rapidamente.
Cenário 2: Pesquisa Não Otimizada
Uma consulta SQL que utilize um filtro apenas no campo DAT NÃO será otimizada por este índice. O banco de dados executará uma varredura completa na tabela (table scan), o que é um processo lento.

DIRETRIZ PRÁTICA DE IMPLEMENTAÇÃO
A ordem dos campos em um índice é o fator mais importante para a performance. Para cada campo que é frequentemente usado como critério de busca em consultas SQL, deve existir um índice que comece por ele.
Para otimizar buscas tanto por CLI quanto por DAT no exemplo acima, a solução correta seria criar dois índices distintos:
Índice 1: CLI;DAT (Otimiza buscas por CLI)
Índice 2: DAT;CLI (Otimiza buscas por DAT)
	
COMPARAÇÃO DE MÉTODOS DE BUSCA: FINDKEY VS LOCATE
Ambos os métodos, FindKey e Locate, são utilizados para localizar registros. No entanto, eles operam de maneiras fundamentalmente diferentes, com implicações diretas na performance e no uso.
MÉTODO: FINDKEY
Uso Principal:
Localização de registros de alta performance.
Onde Funciona:
Funciona SOMENTE em tabelas (TTable). Não funciona em queries.
Como Funciona (Mecanismo de Busca):
Utiliza obrigatoriamente o índice que está ativo na tabela no momento da busca. A pesquisa é sempre otimizada e extremamente rápida.
Requisito:
A tabela deve estar com o índice correto selecionado antes da chamada do método.

MÉTODO: LOCATE
Uso Principal:
Localização de registros de forma flexível.
Onde Funciona:
Funciona tanto em tabelas (TTable) quanto em queries (TQuery).
Como Funciona (Mecanismo de Busca):
Possui um comportamento duplo:
Otimizado: Se existir um índice compatível com os campos da busca, o Locate o utilizará para uma pesquisa rápida.
Não Otimizado: Se NÃO existir um índice compatível, o Locate fará uma busca sequencial, percorrendo a tabela registro a registro do início ao fim. Este processo é muito lento em tabelas grandes.

DIRETRIZ DE USO E PERFORMANCE
Use FindKey sempre que a performance for crítica e você estiver trabalhando diretamente em uma tabela com um índice já definido. É o método mais rápido e eficiente.
Use Locate quando precisar de mais flexibilidade, como em queries, ou quando a busca for em campos não indexados. Esteja ciente do risco de lentidão se não houver um índice de apoio para a sua busca.
	
USO DE FAIXAS DE DADOS (RANGE)
DEFINIÇÃO
O método de RANGE é utilizado para filtrar e extrair um subconjunto específico de registros de uma tabela, criando uma "visão" temporária contendo apenas os dados daquela faixa.
REQUISITO FUNDAMENTAL
Para definir uma faixa, a tabela deve obrigatoriamente estar com um índice ativo que corresponda ao campo ou campos que serão utilizados para definir o início e o fim da faixa.
COMANDOS PRINCIPAIS
SETRANGE
Este é o método utilizado para definir e ativar a faixa de dados.
CANCELRANGE
Este método é utilizado para desativar a faixa e fazer com que a tabela volte a exibir todos os registros.

REGRAS CRÍTICAS DE COMPORTAMENTO
Travamento do Índice
Após a ativação de um RANGE com SETRANGE, o índice da tabela não pode ser alterado. Se o índice for modificado, o RANGE é automaticamente cancelado.
Escopo de Operação
Enquanto um RANGE estiver ativo, todos os métodos de navegação e busca na tabela funcionarão exclusivamente dentro da faixa de dados definida. Métodos como First, Last, Next, Prior, Eof, Bof, FindKey e Locate irão operar apenas sobre o subconjunto de registros extraído, ignorando todos os outros registros da tabela.

EXEMPLO PRÁTICO DE USO
O código abaixo demonstra um cenário comum: percorrer uma tabela de pedidos (TPev) e, para cada pedido, criar uma faixa na tabela de itens (TIve) para processar apenas os itens daquele pedido específico.
Código em Delphi Pascal para implementação de setRange:
TPev.First;
while not TPev.Eof do begin
TIve.SetRange([TPev.Geti('Emp'), TPev.Gets('Num')]);
while not TIve.Eof do begin
    if TIve.Gets('Ope') <> 'Normal' then begin
        TIve.Next;
        Continue;
    end;
    if bEmb then begin
        nQtd := TIve.Getf('QteNum');
    end else begin
        nQtd := TIve.Getf('Qtd');
    end;
    if trunca(nQtd,4) <> trunca(TIve.Getf('QteSep'),4) then begin
        Concatena(cErr,'Pedido ' + TPev.Getk('Num') + ' - Item ' + TIve.Gets('Seq') + ' - Material: ' + TIve.Gets('Mat') + ', ');
    end;
    TIve.Next;
end;
TPev.Next;
end;
Análise do Exemplo:
O loop externo percorre a tabela de pedidos (TPev).
A cada iteração, TIve.SetRange é chamado para filtrar a tabela de itens (TIve), mostrando apenas os itens que correspondem à empresa (Emp) and número do pedido (Num) do registro atual em TPev.
O loop interno então processa apenas os itens pertencentes àquele pedido específico, otimizando a lógica e evitando a necessidade de varrer a tabela de itens inteira repetidamente.

NAVEGAÇÃO DE REGISTROS EM TABELAS E QUERIES
Para navegar entre os registros de uma tabela ou query, ou seja, para mudar o registro ativo (ponteiro), os seguintes métodos devem ser utilizados. A navegação sempre respeita a ordem definida pelo índice ativo no momento.
MÉTODOS DE MOVIMENTAÇÃO DO PONTEIRO
First
Posiciona o ponteiro no primeiro registro, de acordo com a ordem do índice ativo.
Next
Move o ponteiro para o próximo registro, seguindo a ordem do índice ativo.
Prior
Move o ponteiro para o registro anterior, seguindo a ordem do índice ativo.
Last
Posiciona o ponteiro no último registro, de acordo com a ordem do índice ativo.

FLAGS DE LIMITE DE DADOS (BOF E EOF)
As flags BOF (Beginning Of File) e EOF (End Of File) são utilizadas para verificar se o ponteiro ultrapassou os limites do conjunto de dados. Elas NÃO indicam se o ponteiro está no primeiro ou no último registro, mas sim se uma tentativa de movimento para além deles ocorreu.
EOF (End Of File)
A flag EOF é ativada (se torna True) quando o ponteiro está no último registro e o método Next é chamado. O ponteiro passa a apontar para "depois" do último registro.
BOF (Beginning Of File)
A flag BOF é ativada (se torna True) quando o ponteiro está no primeiro registro e o método Prior é chamado. O ponteiro passa a apontar para "antes" do primeiro registro.
Padrão de Uso em Loops:
O padrão mais comum para percorrer todos os registros é utilizar while not Eof, que garante que o loop continue enquanto o ponteiro estiver posicionado em um registro válido.

DIRETRIZ DE USO: TABELAS VS QUERIES
Uma decisão comum no desenvolvimento é escolher entre o acesso direto a tabelas (TTable) e o uso de queries (TQuery). Cada componente tem um propósito específico.
COMPONENTE: TABELAS (TTABLE)
Uso Principal:
Manutenção de dados, como inclusão, alteração e exclusão de registros (operações de CRUD - Create, Read, Update, Delete).
Características:
O acesso utilizando tabelas é sempre o método de mais alta performance para manipulação de dados, pois interage diretamente com os arquivos e índices.
É menos flexível para consultas complexas que envolvem múltiplos filtros e ordenações dinâmicas.
Quando usar:
Utilize tabelas para telas de cadastro e manutenção onde as operações são focadas em um único registro ou em um conjunto de dados com filtros e ordem simples, definidos por um índice ativo.

COMPONENTE: QUERIES (TQUERY)
Uso Principal:
Consultas e relatórios de dados, permitindo a aplicação de múltiplos critérios de filtro e ordenações complexas.
Características:
Oferecem máxima flexibilidade para montar instruções SQL dinâmicas, ajustadas conforme a necessidade do usuário.
A performance de uma query depende criticamente da existência de índices que otimizem as cláusulas de busca (WHERE). Uma query sem os índices apropriados será extremamente lenta.
Quando usar:
Utilize queries para telas de busca, grades de visualização de dados, relatórios e qualquer situação que exija filtros, junções (joins) ou ordenações que não correspondem diretamente a um único índice de tabela.
DIRETRIZ GERAL
Não existe uma regra única para todos os casos. A decisão deve ser planejada. Use Tabelas para performance em manutenção de dados e Queries para flexibilidade em consultas.

EXEMPLO DE USO PRÁTICO DE QUERY
O código abaixo demonstra como construir dinamicamente uma consulta complexa para uma tela de busca, adicionando condições (filtros) com base na entrada do usuário.
Código em Delphi Pascal:
Passo 1: Construção da Cláusula WHERE dinamicamente
Q.ClearCond;
Q.AddCondI('emp','=',ValorInt(EEmp.Text));
Q.AddCondD('dat','>=',dIni);
Q.AddCondD('dat','<=',dFim);
Q.AddCondS('sit','=',ESit.Text);
if not Empty(ERef.Text) then begin
Q.AddCondSql('textsearch('+QuotedStr(ERef.Text)+' in ref)');
end;
Passo 2: Montagem da Instrução SQL Completa
Q.Sql.Clear;
Q.Sql.Add('select * from hose');
Q.Sql.Add('where '+Q.GetWhere);
Q.Sql.Add('order by emp, num');
Passo 3: Associação com a Tabela Principal (se necessário)
Q.MainTable := D.TOse;
Passo 4: Definição das Colunas de Exibição
Q.Clear;
Q.Add('Num;Número');
Q.Add('Dat;Data');
Q.Add('Ref;Referência');
Q.Add('Cli;Cliente');
Q.AddCalc('CliNom',GetPublicPar('CLINOM'),ftString,40,'');
Q.Add('HorPre;^Previsto');
Q.Add('HorRea;^Realizado');
Q.Add('Mat;Total materiais');
Q.Add('Svc;Total serviços');
Q.Add('Dsc;Descontos');
Q.Add('Tot;Total geral');
Passo 5: Execução da Query
ShowWait('Aguarde, preparando as informações...');
Q.RefreshTables;
Q.Open;
	
Ok, vamos otimizar este trecho, que é uma diretriz de performance muito importante. A chave é deixar claro por que os filtros devem ser evitados e qual é a forma correta de usá-los nos raros casos em que são necessários.

A estrutura abaixo foi pensada para guiar o LLM a sempre preferir a solução mais performática (Índices ou SQL) e entender o filtro como uma exceção.

USO DE FILTROS EM TABELAS E QUERIES (DBISAM)

DIRETRIZ PRINCIPAL: EVITAR O USO DE FILTROS
A recomendação padrão é evitar o uso de filtros para restringir dados.
Na grande maioria dos cenários, os mesmos resultados podem ser obtidos de forma muito mais eficiente utilizando uma das seguintes abordagens:
Tabelas (TTable) com índices apropriados (usando SetRange ou FindKey).
Queries (TQuery) com cláusulas WHERE bem definidas em código SQL.

JUSTIFICATIVA DA RECOMENDAÇÃO
Filtros no DBISAM operam do lado do cliente, o que significa que todos os dados são primeiro trazidos do banco de dados para a memória da aplicação, e só então o filtro é aplicado. Este processo é ineficiente e consome muitos recursos, resultando em lentidão, especialmente em tabelas com muitos registros.
Em contraste, Índices e cláusulas WHERE operam do lado do servidor (banco de dados), trazendo para a aplicação apenas os registros que já correspondem ao critério, o que é muito mais rápido.

USO EM CASOS DE EXCEÇÃO
Embora deva ser evitado, o recurso de filtro está disponível para situações onde as alternativas não são viáveis.
Existem duas formas de implementar um filtro:
Propriedade Filter (Para Filtros Simples)
Esta propriedade permite definir uma condição de filtro simples através de uma string.
Implementação:
a. Atribua a condição à propriedade Filter.
b. Ative o filtro com a propriedade Filtered := True.
c. Reposicione o ponteiro para o início do conjunto de dados filtrado.
Exemplo de Código em Delphi Pascal:
TOse.Filter := 'sta = ' + IntToStr(ValorInt(ESta.Text));
TOse.Filtered := True;
TOse.First;
Evento OnFilterRecord (Para Filtros Complexos)
Este evento oferece controle total para criar lógicas de filtro complexas, que não seriam possíveis com a propriedade Filter. O código para avaliar se um registro deve ou não ser exibido é escrito diretamente dentro deste evento.

OTIMIZAÇÃO DE CONSULTAS: CAMPOS CALCULADOS VS. SQL JOIN

DIRETRIZ DE PERFORMANCE
Por questões de desempenho, a abordagem preferencial é evitar o uso de consultas SQL com múltiplas tabelas (JOINs). Em vez disso, deve-se utilizar o recurso de campos calculados (virtuais) em uma query que consulta uma única tabela principal.
A utilização de campos calculados resulta em uma performance de carregamento de dados significativamente superior.
ABORDAGEM 1: USO DE CAMPOS CALCULADOS (VIRTUAIS) - RECOMENDADO
Esta técnica consiste em adicionar campos a uma query que não existem fisicamente na tabela principal. O valor desses campos é calculado e preenchido em tempo de execução, geralmente buscando informações relacionadas em outras tabelas.
Quando Usar:
É a abordagem ideal para exibir informações de tabelas relacionadas (como o nome de um cliente em uma tabela de pedidos) sem a necessidade de um JOIN no SQL.
Implementação:
O processo ocorre em dois passos:
Definição do Campo: O campo calculado é definido na estrutura da query, geralmente com o método AddCalc.
Cálculo do Valor: A lógica para calcular o valor do campo é escrita no evento OnCalcFields do componente da query.

Exemplo Prático de Implementação:
O código abaixo demonstra como uma query de pedidos (TPec) utiliza campos calculados para exibir nomes de clientes (CliNom), descrições de índices (MosDes) e nomes de departamentos (DepDes) sem usar JOINs.
Passo A: Definição do Campo Calculado
TPec.AddCalc('DepDes','Departamento',ftString,40);
Passo B: Lógica de Cálculo no Evento OnCalcFields
procedure TFPec01.TPecCalcFields(DataSet: TDataSet);
var nFat: Real;
begin
if not IsFor then begin
if TCli.FindKey([TPec.Geti('For')]) then begin
TPec.Puts('CliNom', PessoaNome(TCli));
TPec.Puts('CliCpx', TCli.Gets('Cpx'));
end;
end;
 if TPec.NotEmpty('Bru') then begin
     nFat := TPec.Getf('BruEnt') / TPec.Getf('Bru');
 end else begin
     nFat := 0;
 end;
 TPec.Putf('TotEnt', trunca(TPec.Getf('Tot') * nFat,2));
 if TInd.FindKey([TPec.Geti('Mos')]) then begin
     TPec.Puts('MosDes', TInd.Gets('Des'));
 end;
 if TDep.FindKey([TPec.GetF('Dep')]) then begin
     TPec.Puts('DepDes', TDep.Gets('Nom'));
 end;
end;

ABORDAGEM 2: USO DE JOIN EM SQL (SITUAÇÃO DE EXCEÇÃO)
Quando Usar:
O uso de um SQL com JOIN (mais de uma tabela) torna-se necessário principalmente em uma situação específica: quando existe a necessidade de ordenar o resultado da consulta por um campo que pertence a uma tabela secundária.
Como o evento OnCalcFields ocorre após a ordenação dos dados, ele não pode ser usado para esse fim, tornando o JOIN a única alternativa viável.
Ok, vamos refinar este trecho sobre o Modelo Entidade-Relacionamento. A estrutura a seguir foi projetada para que o RAG possa facilmente extrair a definição de cada componente ou regra de cardinalidade de forma isolada.

MODELO ENTIDADE-RELACIONAMENTO (MER)
DEFINIÇÃO
O Modelo Entidade-Relacionamento, conhecido como MER, é um modelo de dados abstrato e conceitual. Sua finalidade é descrever os dados de um domínio ou de um sistema de informação.
DIAGRAMA ENTIDADE-RELACIONAMENTO (DER)
A principal ferramenta do MER é sua representação gráfica, o Diagrama Entidade-Relacionamento (DER). Ele visualiza a estrutura dos dados e suas interações.

COMPONENTES DO DIAGRAMA (NOTACAO ORIGINAL)
Entidades
Representadas por retângulos, são os objetos ou conceitos sobre os quais se deseja armazenar informações (ex: Clientes, Pedidos, Produtos).
Atributos
Representados por círculos, são as propriedades ou características de uma entidade (ex: para a entidade Cliente, os atributos seriam Nome, Endereço, Telefone).
Relacionamentos
Representados por losangos, descrevem como as entidades se associam ou interagem entre si (ex: um Cliente "faz" um Pedido).

TIPOS DE RELACIONAMENTO (CARDINALIDADE)
A cardinalidade define a quantidade de instâncias de uma entidade que podem se relacionar com instâncias de outra entidade.
Relação 1..1 (Um para Um)
Indica que um registro em uma tabela se relaciona com, no máximo, um registro em outra tabela, e vice-versa. A relação é unívoca.
Regra de Chave Estrangeira: A chave estrangeira pode ser colocada em qualquer uma das duas tabelas.
Relação 1..n (Um para Muitos)
Este é o tipo de relacionamento mais comum. Um registro em uma tabela pode se relacionar com muitos registros em outra, mas um registro da segunda tabela só pode se relacionar com um da primeira.
Regra de Chave Estrangeira: A chave primária da tabela do lado "1" é adicionada como chave estrangeira na tabela do lado "n".
Relação n..n (Muitos para Muitos)
Indica que muitos registros em uma tabela podem se relacionar com muitos registros em outra.
Regra de Implementação: Este relacionamento não pode ser implementado diretamente. É necessário criar uma terceira tabela, chamada de tabela associativa ou de ligação.
Esta nova tabela conterá as chaves primárias de ambas as tabelas originais, formando uma chave primária composta. O relacionamento "n..n" é então decomposto em dois relacionamentos "1..n", com o lado "n" de ambos apontando para a nova tabela associativa.

FERRAMENTA DE GERAÇÃO DE PROJETOS: GENAPLIC
OBJETIVO PRINCIPAL
A ferramenta GenAplic tem como finalidade principal automatizar a criação da estrutura inicial de um novo projeto de software, servindo como o ponto de partida para o desenvolvimento.
FUNCIONALIDADES EXECUTADAS
Ao ser utilizado, o GenAplic realiza as seguintes ações de configuração e criação:
Definição do Nome do Projeto
Especifica o nome do arquivo de projeto principal (extensão DPR).
Definição de Títulos
Configura o nome do sistema e o título da aplicação que será exibido.
Criação da Estrutura de Pastas
Cria o diretório raiz onde todos os arquivos relacionados ao projeto serão armazenados. Esta ação só é executada se a pasta ainda não existir.
RESULTADO FINAL
Após a execução do GenAplic, o desenvolvedor terá um esqueleto de projeto pronto, com a estrutura de pastas e os nomes de arquivos e títulos já definidos, permitindo que o desenvolvimento das funcionalidades comece imediatamente.

FERRAMENTA DE GESTÃO DE BANCO DE DADOS: GENFILES
OBJETIVO PRINCIPAL
A ferramenta GenFiles possui um duplo objetivo: atuar como um gerador de documentação da estrutura do banco de dados e como um gerador de código completo para a manutenção dessa estrutura.
FUNCIONALIDADES DE DOCUMENTAÇÃO
O GenFiles analisa o projeto e gera uma documentação técnica detalhada, especificando os seguintes itens do banco de dados:
Tabelas
Campos de cada tabela
Índices existentes
Regras de Integridade Referencial
FUNCIONALIDADES DE GERAÇÃO DE CÓDIGO
A ferramenta gera automaticamente todo o código necessário para realizar a manutenção e evolução da estrutura do banco de dados. As rotinas geradas abrangem:
Criação de novas tabelas.
Criação e/ou alteração de campos em tabelas existentes.
Criação e/ou alteração de índices.
Reorganização de arquivos de dados.
Definição de máscaras de entrada para campos.
Definição de campos obrigatórios.
Outros recursos relacionados à estrutura dos dados.
RESULTADO FINAL
O uso do GenFiles automatiza tarefas complexas e repetitivas de administração do banco de dados, garantindo que a documentação e o código de manutenção estejam sempre sincronizados com a estrutura real das tabelas.

FERRAMENTA DE GERAÇÃO DE FORMULÁRIOS: GENFORM
OBJETIVO PRINCIPAL
O GenForm é uma ferramenta de alta produtividade projetada para gerar automaticamente a estrutura e o código-fonte completos para formulários de sistemas.
COMO FUNCIONA
Com base em informações e definições previamente inseridas (provavelmente a partir da estrutura de uma tabela do GenFiles), o GenForm cria todo o código boilerplate necessário para a tela. Isso inclui a interface visual e as conexões de dados.
PRINCIPAL BENEFÍCIO
A utilização do GenForm acelera significativamente o desenvolvimento de um projeto. Ao automatizar a criação de formulários, a ferramenta permite que o foco do desenvolvedor seja direcionado exclusivamente para a implementação das regras de negócio e da lógica específica do problema, em vez de gastar tempo com tarefas repetitivas de construção de interface.

UTILITÁRIO DE GERENCIAMENTO: DBM (DATABASE MANAGER)
DEFINIÇÃO E OBJETIVO
O DBM é o utilitário oficial para gerenciamento do banco de dados DBISAM. Seu objetivo é fornecer uma interface direta para que o desenvolvedor possa administrar e interagir com toda a estrutura e os dados do banco.
FUNCIONALIDADES DE ADMINISTRAÇÃO DA ESTRUTURA (SCHEMA)
O DBM permite realizar modificações diretas na estrutura das tabelas e arquivos do banco de dados. As principais funções administrativas são:
Criação de novas tabelas.
Alteração da estrutura de tabelas existentes.
Criação ou atualização de índices.
Reparação de tabelas que apresentam problemas de integridade.
FUNCIONALIDADES DE MANIPULAÇÃO E ANÁLISE DE DADOS
A ferramenta também oferece um conjunto de recursos práticos para o desenvolvedor interagir com os dados durante o desenvolvimento e a depuração. As principais funções de análise são:
Localizar registros específicos (semelhante ao Locate/FindKey).
Alterar o índice ativo de uma tabela para visualizar diferentes ordenações.
Aplicar e testar faixas de dados (Ranges).
Filtrar os dados de uma tabela para visualizar subconjuntos.
Gerar e executar códigos SQL diretamente no banco de dados.
Muitos outros recursos para inspeção e manipulação de dados.



SERVIÇO DE PROCESSAMENTO: RPSERVER
DEFINIÇÃO E INSTALAÇÃO
O RPServer é um serviço que é instalado juntamente com o aplicativo servidor do banco de dados. Sua função é permitir a execução de rotinas e processos diretamente no servidor.
CASO DE USO 1: PROCESSAMENTO DO LADO DO SERVIDOR (SERVER-SIDE)
Objetivo:
Otimizar a performance de operações que manipulam grandes volumes de dados.
Como Funciona:
Ao utilizar o RPServer, as funções são executadas diretamente na base de dados, no próprio servidor. Isso evita o tráfego de grandes quantidades de dados pela rede até a estação cliente para serem processados.
Benefício:
A redução drástica do tráfego de rede resulta em um aumento significativo de velocidade e eficiência, principalmente em redes com menor largura de banda.

CASO DE USO 2: EXECUÇÃO DE TAREFAS AGENDADAS
Objetivo:
Automatizar rotinas e processos que devem ser executados sem intervenção do usuário.
Como Funciona:
O RPServer pode ser configurado para executar tarefas em horários predeterminados.
Exemplos de Tarefas:
Processamentos noturnos.
Rotinas de backup.
Geração de relatórios agendados.
Sincronização de dados.

FERRAMENTA DE EDIÇÃO DE TEXTO: HPROEDIT
DEFINIÇÃO
O HProEdit é um editor de textos avançado, desenvolvido como uma alternativa mais poderosa ao Bloco de Notas padrão.
CARACTERÍSTICA PRINCIPAL
Sua arquitetura é multi-janelas, permitindo ao usuário abrir e trabalhar com múltiplos arquivos simultaneamente na mesma instância do programa.
PRINCIPAIS USOS
A ferramenta é projetada para agilizar o trabalho de desenvolvedores e analistas, oferecendo recursos para a análise eficiente de diversos tipos de arquivos de texto, incluindo:
Arquivos de texto puro (TXT, LOG, etc.).
Arquivos de dados estruturados como XML.
Arquivos de dados estruturados como JSON.

SERVIDOR WEB: HPROWS (ANTERIORMENTE HWSERVER)
DEFINIÇÃO
O HProWS é um servidor web totalmente desenvolvido pela HPro Informática. Sua principal função é atuar como a ponte de integração entre aplicações na internet e o banco de dados interno da empresa.
CARACTERÍSTICAS PRINCIPAIS
Alta Disponibilidade
O servidor é projetado para alta disponibilidade, utilizando uma arquitetura multi-thread que permite o processamento de múltiplas requisições simultaneamente. Ele opera como um serviço padrão do Windows, garantindo sua execução contínua em segundo plano.
Integração com o Banco de Dados
Ele provê uma camada de integração direta com o banco de dados interno. Toda a lógica de backend e acesso aos dados é desenvolvida utilizando a linguagem Delphi padrão, com todos os recursos necessários disponibilizados pela HPro.
Baixo Consumo de Recursos
O HProWS é otimizado para ser leve, utilizando poucos recursos de hardware do servidor, como memória e processamento.

DIRETRIZES DE DESENVOLVIMENTO E REGRAS DE NEGÓCIO
REGRAS DE USO DO DATAMODULO
O DataModulo deve ser utilizado exclusivamente para hospedar os componentes de acesso a dados. Nenhuma outra lógica deve ser implementada nele.
Proibido o uso de Range
Nunca aplique faixas de dados (Range) em tabelas que residem no DataModulo.
Proibida a mudança de Índice
Nunca altere o índice ativo de tabelas que residem no DataModulo.
Proibida a programação de Lógica
Nunca implemente código ou regras de negócio diretamente nos eventos do DataModulo.

REGRAS PARA COMPONENTES DE DADOS (TABELAS E GRIDS)
Conexão de Grids
Componentes visuais de grade (Grids) devem sempre estar conectados a componentes de tabela locais ao formulário, e não diretamente a tabelas no DataModulo.
Abertura de Tabelas
As tabelas devem ser abertas, preferencialmente, no evento OnCreate do formulário que as utiliza.
Definição de Índices
O índice de uma tabela deve ser definido no momento de sua abertura, antes do comando "Open". Esta regra se aplica em quase 100% dos casos.

REGRAS GERAIS DE INTERFACE E FUNCIONALIDADE
Nomenclatura de Tabelas e Campos
Os nomes de tabelas e campos devem seguir estritamente as recomendações de nomenclatura da HPro (consultar documento anexo de padrões).
Totalização de Valores em Consultas
Em todas as telas de consulta que exibem valores numéricos (como financeiros ou de quantidade), deve existir um botão ou funcionalidade para "Totalizar" os valores exibidos.
Totalização em Impressões
Onde houver valores em relatórios ou listagens para impressão, os mesmos também deverão ser totalizados.

REGRA DE FORMATAÇÃO DE DADOS (MÁSCARAS)
Princípio:
Ao utilizar máscaras de entrada de dados na interface do usuário, o valor deve ser sempre armazenado no banco de dados sem os caracteres da máscara. O dado deve ser salvo em seu formato puro.
Exemplo Prático:
Um valor exibido na tela como "05/002" deve ser gravado no banco de dados como "05002". A lógica para remover e aplicar a máscara deve existir na aplicação.

DIRETRIZES DE INTERFACE DE USUÁRIO (UI) E FORMATAÇÃO
LARGURA DE CAMPOS DE CÓDIGO
Componentes do tipo Edit ou DBEdit que são utilizados para exibir ou inserir códigos devem ter uma largura mínima de 45 pixels.
LARGURA DE COMPONENTE VIEW
A largura padrão para componentes do tipo View deve ser de 300 pixels.
LARGURA DE CAMPOS DE DATA
Componentes do tipo MaskEdit ou DBEdit que representam datas devem ter uma largura padrão de 75 pixels.
LARGURA DE CAMPOS DE VALOR DECIMAL
Componentes do tipo EditNum ou DBEdit que representam valores com casas decimais devem ter uma largura mínima de 75 pixels.
MÁSCARA PADRÃO PARA VALORES
A máscara de formatação padrão para exibição de valores monetários ou decimais é: #,###,##0.00

ESTRUTURA DA BIBLIOTECA HPRO
A biblioteca HPro é composta por um conjunto de units (unidades de código), cada uma com uma responsabilidade específica. As units mais importantes são:
HProFunc.pas
Contém funções básicas e de utilização genérica, que podem ser aproveitadas em diversas partes de qualquer sistema.
HProDB.pas
Agrupa as funções relacionadas ao acesso, controle e manipulação de dados do banco de dados.
HProWin.pas
Contém funções de caráter visual, diretamente atreladas ao controle de componentes visuais do Windows (formulários, botões, grades, etc.).
HProConst.pas
Utilizada como um repositório central para armazenar as constantes e variáveis "públicas" (globais) do sistema.

RESUMO DE FUNÇÕES DA UNIT HPROFUNC.PAS
MENSAGENS E INTERAÇÃO COM USUÁRIO
Atencao
Exibe mensagens de aviso para o usuário e pode ser usada para solicitar confirmações (Sim/Não).
Exemplo de código:
Atencao('Númeração de controle da Nota Fiscal fora de sequência;;Entre em contato com o suporte técnico');
Beep
Emite um som de bip padrão do sistema.
Exemplo de código:
beep;
ShowWait / HideWait
Respectivamente, exibe e esconde a janela "Aguarde, processando..." para o usuário durante operações demoradas.
Exemplo de código:
ShowWait('Aguarde, excluindo...');
           Q.ConsultFrom;
           D.Transaction;
           D.TCkl.Delete;
           D.Commit;
           Q.Refresh;
HideWait;

CONVERSÃO DE TIPOS DE DADOS
ctod
Converte uma string (texto) em uma data.
Exemplo de código:
dAux := CtoD('01/04/2022');
dtoc
Converte uma data em uma string no formato dd/mm/aaaa.
Exemplo de código:
EDvd.Text := dtoc(Date);
DateToSql (ou DtoSql)
Converte uma data para o formato padrão SQL: aaaa-mm-dd.
FloatToSql
Converte um número de ponto flutuante (real) para o formato SQL, usando o ponto como separador decimal.
Hton
Converte uma string de tempo no formato "hh:mm" para um número, permitindo cálculos com horas.
Ntoh
Converte um número de volta para uma string de tempo no formato "hh:mm", usado em conjunto com a função Hton.
Valor
Converte uma string em um número com casas decimais.
Exemplo de Código:
nEmp := Valor('1.05');
ValorInt
Converte uma string em um número inteiro.
Exemplo de Código:
nEmp := ValorInt('1');

TRATAMENTO DE STRINGS
Empty
Verifica se uma string, data ou número está vazio/nulo/zero. Retorna True se estiver vazio.
Exemplo de código:
var cAux: String;
begin
     cAux := OnlyNumber(ECpj.Text);
     if empty(cAux) then begin
Fill
Formata uma string com preenchimento de caracteres, útil para gerar arquivos com layouts de tamanho fixo.
OnlyNumber
Extrai e retorna apenas os caracteres numéricos de uma string. Exemplo: "12/1233-44" retorna "12123344".
Parse
Extrai um trecho de uma string com base em um caractere separador.
Exemplo de código:
cAux := TMem.Gets('Key');
cEmp := Parse(cAux);
cCad := Parse(cAux);
Replicate
Repete um caractere um determinado número de vezes. Exemplo: Replicate('*', 5) retorna "*****".
Spaces
Gera uma string contendo um número específico de espaços em branco.
StrTran
Substitui todas as ocorrências de um trecho de texto por outro dentro de uma string.
Transform
Aplica uma máscara de formatação a uma string de dados puros.

MANIPULAÇÃO DE DATAS
FirstDay
Recebe uma data como parâmetro e retorna o primeiro dia do mês correspondente.
LastDay
Recebe uma data como parâmetro e retorna o último dia do mês correspondente.

VALIDAÇÕES
IsCGC ou IsCNPJ
Verifica se um número de CNPJ fornecido é válido, incluindo a checagem do dígito verificador. Retorna True se for válido.
IsCPF
Verifica se um número de CPF fornecido é válido, incluindo a checagem do dígito verificador. Retorna True se for válido.
IsContido
Verifica se um determinado valor está contido dentro de um conjunto de valores.
Exemplo de código:
if IsContido(TIno.Gets('Cfo',1),['5','6','7']) then begin

CONTROLE DE ACESSO
Acesso
Controla os direitos de acesso de um usuário a um determinado processo.
IsAcesso
Verifica se o usuário logado possui permissão para um processo específico.

UTILITÁRIOS DIVERSOS
DBGridColor
Permite colorir uma linha inteira de um DBGrid com base em uma condição lógica.
exemplo de código:
if (TMem.Geti('Niv') = 1) or (TMem.Geti('Niv') = 9) then begin
DbGridColor(Grid,Rect,DataCol,Column,State,clMoneyGreen);
end else if TMem.Geti('Niv') = 3 then begin
DbGridColor(Grid,Rect,DataCol,Column,State,clSkyBlue);
end;

FloatControl
Permite que o usuário visualize e navegue por um campo do tipo memo mesmo quando o painel ou formulário está desabilitado.

GetPublicPar
Retorna o conteúdo de um parâmetro público do sistema. O valor retornado é sempre uma string.
Exemplo de código:
if GetPublicPar('BANNEG') = 'Não' then begin

PerformSQL
Conjunto de funções para execução rápida de comandos SQL simples diretamente no banco de dados.

Trunca
Arredonda um valor numérico para um número específico de casas decimais.
Exemplo de código:
nMed := trunca(nMed,4);

UserQuery
(A descrição está faltando, mas provavelmente relacionado a consultas personalizadas do usuário).

FUNÇÕES OBSOLETAS

FindOrder
NÃO UTILIZAR. Esta função foi descontinuada.

COMPONENTE PERSONALIZADO: HPROTABLE

DEFINIÇÃO E OBJETIVO
Para suportar recursos específicos da HPro Informática e agilizar o desenvolvimento, foi criado o componente HproTable, um descendente direto do TDBISAMTable.

O HproTable herda todas as funcionalidades do componente padrão do DBISAM e adiciona uma série de métodos e recursos adicionais para simplificar o código e aumentar a produtividade.

OBTENDO VALORES DE CAMPOS: A SOLUÇÃO HPROTABLE
O PROBLEMA COM O MÉTODO PADRÃO (FIELDBYNAME)
O método padrão do Delphi para acessar o valor de um campo é Tabela.FieldByName('NomeDoCampo').AsTipo. A principal desvantagem deste método é que ele resulta em um código longo, repetitivo e de difícil leitura.
A SOLUÇÃO: MÉTODOS "GET" SIMPLIFICADOS
Para resolver este problema, o HproTable introduz um conjunto de métodos curtos e intuitivos para obter valores de campos, cada um específico para um tipo de dado.
LISTA DE MÉTODOS "GET" DO HPROTABLE
Geti
Para obter valores do tipo Inteiro.
Getd
Para obter valores do tipo Data.
Getf
Para obter valores de ponto flutuante (com casas decimais), como BCD ou Float.
Gets
Para obter valores de texto, como String ou Memo.
Getk
Para obter o valor de um campo já com a máscara de formatação aplicada.

EXEMPLOS COMPARATIVOS
Obtendo um valor Inteiro:
Método Padrão: Tabela.FieldByName('Cod').AsInteger
Método HproTable: Tabela.Geti('Cod')

Obtendo um valor de Data:
Método Padrão: Tabela.FieldByName('Emi').AsDateTime
Método HproTable: Tabela.Getd('Emi')

Obtendo um valor de String:
Método Padrão: Tabela.FieldByName('Nome').AsString
Método HproTable: Tabela.Gets('Nome')

ATRIBUINDO VALORES A CAMPOS: A SOLUÇÃO HPROTABLE

Seguindo a mesma lógica de simplificação dos métodos "Get", o HproTable oferece um conjunto de métodos "Put" para atribuir valores a campos de forma rápida e intuitiva.

O PROBLEMA COM O MÉTODO PADRÃO (FIELDBYNAME)
O método padrão do Delphi para atribuir um valor a um campo é Tabela.FieldByName('NomeDoCampo').AsTipo := Valor, que, assim como na obtenção de dados, é longo e verboso.

A SOLUÇÃO: MÉTODOS "PUT" SIMPLIFICADOS
O HproTable substitui a sintaxe padrão por métodos curtos que recebem o nome do campo e o valor a ser atribuído como parâmetros.
LISTA DE MÉTODOS "PUT" DO HPROTABLE
Puti
Para atribuir valores do tipo Inteiro.
Putd
Para atribuir valores do tipo Data.
Putf
Para atribuir valores de ponto flutuante (com casas decimais), como BCD ou Float.
Puts
Para atribuir valores de texto, como String ou Memo.

Observação sobre o método Putk:
Embora exista, o uso do Putk para atribuir valores mascarados deve seguir a diretriz de que os dados devem ser sempre armazenados sem a máscara.

EXEMPLOS COMPARATIVOS

Atribuindo um valor Inteiro:
Método Padrão: Tabela.FieldByName('Cod').AsInteger := nCodigo
Método HproTable: Tabela.Puti('Cod', nCodigo)

Atribuindo um valor de Data:
Método Padrão: Tabela.FieldByName('Emi').AsDateTime := dEmissao
Método HproTable: Tabela.Putd('Emi', dEmissao)

Atribuindo um valor de String:
Método Padrão: Tabela.FieldByName('Nome').AsString := sNome
Método HproTable: Tabela.Puts('Nome', sNome)

CONCEITOS DE EXECUÇÃO DE QUERIES: LIVERESULT VS. CANNED RESULT

Ao executar uma query no DBISAM, o resultado pode ser obtido de duas maneiras distintas: Live (ao vivo) ou Canned (enlatado). A propriedade LiveResult de uma query, disponível somente após sua execução, indica qual modo foi utilizado.

CONCEITO 1: LIVE RESULT (RESULTADO AO VIVO)

Definição:
Um resultado é considerado "Live" quando a query consegue acessar os dados diretamente nas tabelas originais, utilizando os índices e filtros internos do banco de dados de forma otimizada.

Como Verificar:
A propriedade Q.LiveResult retorna True.

Comportamento Principal:
Qualquer alteração (edição, exclusão) feita nos dados da query com LiveResult = True é refletida imediatamente na tabela original correspondente. A conexão com os dados é direta.

CONCEITO 2: CANNED RESULT (RESULTADO ENLATADO)

Definição:
Um resultado é considerado "Canned" quando o DBISAM não consegue acessar os dados de forma otimizada e precisa criar uma tabela temporária em memória para armazenar o conjunto de resultados da consulta.

Como Verificar:
A propriedade Q.LiveResult retorna False.

Comportamento Principal (Aviso Crítico):
Qualquer alteração (edição, exclusão) feita nos dados de uma query com resultado "Canned" NÃO será refletida na tabela original. As modificações são feitas apenas na cópia temporária e são perdidas quando a query é fechada.

FATORES QUE CAUSAM UM CANNED RESULT

Uma query resultará em "Canned" (LiveResult = False) nas seguintes situações:

Otimização Impossível: Quando as cláusulas WHERE ou ORDER BY do SQL são complexas e não podem ser resolvidas de forma eficiente pelos índices existentes.

Múltiplas Tabelas (JOIN): Quando a consulta SQL envolve mais de uma tabela (utiliza JOIN), o resultado será SEMPRE "Canned".

PROPRIEDADE DE CONTROLE: REQUESTLIVE

Esta propriedade permite ao desenvolvedor influenciar como o DBISAM tentará obter os dados.

RequestLive = True (Padrão)
O DBISAM tentará obter um LiveResult. Se não for possível devido aos fatores acima, ele automaticamente recorrerá a um Canned Result.

RequestLive = False
O DBISAM forçará a criação de um Canned Result, mesmo que um LiveResult fosse possível.

COMPONENTE DE CONSULTA: THPROVIEW

DEFINIÇÃO E OBJETIVO
O THProView é um dos componentes mais importantes e utilizados da aba Edulib. Seu objetivo é facilitar e padronizar a criação de telas de consulta (lookups), onde o usuário pode pesquisar e selecionar um registro de uma lista.

PROPRIEDADES DE CONFIGURAÇÃO (VIA CÓDIGO)
A configuração de um THProView é feita definindo suas propriedades, principalmente através de instruções SQL distintas para cada cenário de uso.

Title
Define o título que aparecerá na janela de consulta.

SqlValid
Contém a instrução SQL utilizada para validar um código quando o usuário o digita diretamente no campo, em vez de selecioná-lo na lista. Geralmente, retorna a descrição correspondente ao código.

SqlCaption
Contém uma instrução SQL similar à SqlValid, mas é utilizada especificamente em contextos onde a tabela não será editada, como em telas de histórico.

SqlShow
Contém a instrução SQL principal, utilizada para popular a grade (grid) de seleção com os dados que serão exibidos ao usuário.

Query
Propriedade interna que permite configurar a exibição das colunas na grade de consulta.

EXEMPLO PRÁTICO DE CONFIGURAÇÃO
O procedimento abaixo demonstra como configurar um THProView para uma consulta de grupos de materiais.
Código em Delphi Pascal:
procedure VGru(hv: THProView);
begin
with hv do begin
Title := 'Consulta grupos de materiais';
     // Usado quando o usuário digita o código diretamente
     SqlValid := 'select des from hgru where cod=:1 and sit=''Ativo''';
     // Usado para obter a descrição em contextos de "somente leitura"
     SqlCaption := 'select des from hgru where cod=:1';
     // Usado para preencher a grade de seleção
     SqlShow := 'select cod, des from hgru where sit=''Ativo'' order by des nocase';
     // Configuração das colunas da grade
     Query.MainTable := D.TGru;
     Query.Clear;
     Query.Add('Cod;Código');
     Query.Add('Des;Descrição');
 end;
end;

PRINCIPAIS EVENTOS

OnActivate
Este evento é utilizado para chamar e exibir a tela de consulta do View para o usuário.

OnSelect
Este evento é disparado em duas situações:
Quando o usuário seleciona um item na grade de consulta.
Quando o usuário digita um código válido diretamente no campo e o SqlValid retorna um resultado.

PROCEDIMENTO DE IMPRESSÃO COM O COMPONENTE TIMPRESSORA

O componente TImpressora oferece dois modos para a geração de relatórios e impressões: Automático e Manual.

MODO 1: IMPRESSÃO AUTOMÁTICA

Descrição:
Este é o método mais utilizado e serve para impressões rápidas e padronizadas, geralmente baseadas no conteúdo de uma grade (grid) ou tabela.

Etapas para Implementação:

Defina o título do relatório.

Atribua as colunas da tabela que devem ser impressas.

Opcionalmente, defina quais colunas numéricas devem ser totalizadas.

Inicie o processo de impressão.

Exemplo de Código em Delphi Pascal:

Define-se o título do relatório
Imp.Title := 'Título do relatório';

Orienta o componente de impressão a imprimir o que está no grid vinculado a tabela
Imp.Columns.Assign(Tabela.PrintFields);

Define quais colunas deverão ser totalizadas (propriedade opcional)
Imp.SumColumns := 'Tot;Jur';

Inicia o processo de impressão solicitando a escolha da impressora
Imp.Start;

MODO 2: IMPRESSÃO MANUAL

Descrição:
Utilizado para relatórios com layouts complexos e personalizados, que não podem ser gerados automaticamente a partir de um grid. Este modo dá ao desenvolvedor controle total sobre o posicionamento de cada elemento no relatório através de eventos.

Eventos Principais:

OnHeader
Este evento é disparado no início da impressão e é utilizado para imprimir o cabeçalho do relatório, como títulos, informações da empresa, filtros, e os títulos das colunas.

OnDetail
Este evento é disparado para cada registro do conjunto de dados. É utilizado para imprimir o corpo do relatório, ou seja, as linhas de dados.

OnStop
Este evento é disparado no final da impressão, após todos os registros terem sido processados. É utilizado para imprimir o rodapé, como observações, totais gerais, etc.

EXEMPLO PRÁTICO DE IMPLEMENTAÇÃO MANUAL
Exemplo de Código para o Evento OnHeader:
with Imp do begin
Say(Row+1,10,'Número....: '+D.TPecNum.DisplayText+' - Data: '+EDat.Text);
Say(Row+1,10,'Comprador.: '+ECom.Text+' - '+CCom.Text);
Say(Row+1,10,'Fornecedor: '+EFor.Text+' - '+CFor.Text);
Say(Row+1,10,'Contato...: '+ECon.Text);
Say(Row+1,10,'Previsão de entrega..: '+EPre.Text);
Say(Row+1,10,'Condição de Pagamento: '+EPag.Text);
Say(Row+1,10,'Vencimentos..........: ');
Line;
Say(Row+1, 1,'Seq');
Say(Row , 5,'Produto');
Say(Row ,55,'Quantidade');
Say(Row ,66,'P.Unitário');
Say(Row ,77,'Desconto');
Say(Row ,89,'P.Total');
Line;
end;
Exemplo de Código para o Evento OnDetail:
with Imp do begin
Say(Row+1, 1,format('%.3d',[nSeq]));
Say(Row , 5,format('%8.4n',[TIcoPro.Value]));
Say(Row ,14,TIcoPDes.DisplayText);
Say(Row ,56,format('%9.3n',[TIcoQtd.Value]));
Say(Row ,66,format('%10.3n',[TIcoPre.Value]));
Say(Row ,77,format('%8.2n',[TIcoDes.Value]));
Say(Row ,86,format('%10.2n',[TIcoTot.Value]));
end;
Exemplo de Código para o Evento OnStop:
with Imp do begin
Say(Row+2,73,' Total =>');
Say(Row ,86,format('%10.2n',[GetTotal('Tot')]));
// Observações (se houver)
if D.TPec.NotEmpty('Obs') then begin
Say(Row+2,10,'Observações: ');
DefMemoField(D.TPecObs, 70);
for nI := 0 to MemoCount-1 do begin
if nI = 0 then begin
Say(Row,Col,MemoLine(nI));
end else begin
Say(Row+1,10,' '+MemoLine(nI));
end;
end;
end;
Line;
end;

PROCEDIMENTO DE TOTALIZAÇÃO DE VALORES (BOTÃO "TOTALIZAR")

A funcionalidade de totalizar colunas em um conjunto de dados (DataSet) é realizada através da procedure TotalizarDados. Este método é considerado automático e flexível, adaptando-se a diferentes necessidades de sumarização.

FUNÇÃO PRINCIPAL: TotalizarDados

Abaixo estão as diferentes sintaxes para a utilização desta função.

SINTAXE 1: TOTALIZAR UMA ÚNICA COLUNA
Esta é a forma mais simples, utilizada para obter a soma de uma única coluna numérica.
Exemplo de Código:
TotalizarDados(Dataset,'Tot');

Análise:
O primeiro parâmetro (Dataset) é o conjunto de dados a ser processado.
O segundo parâmetro ('Tot') é o nome do campo (coluna) a ser somado.
O resultado será uma mensagem exibindo o total com o título padrão "Total".

SINTAXE 2: TOTALIZAR UMA ÚNICA COLUNA COM TÍTULO PERSONALIZADO
Utilizada quando se deseja alterar o título padrão exibido na mensagem de totalização.
Exemplo de Código:
TotalizarDados(Dataset,'Tot;Valor Total');

Análise:
No segundo parâmetro, o nome do campo ('Tot') é seguido por um ponto e vírgula e pelo título desejado ('Valor Total').

SINTAXE 3: TOTALIZAR MÚLTIPLAS COLUNAS
Utilizada para obter a soma de várias colunas em uma única operação.
Exemplo de Código:
TotalizarDados(TPag,'Val;Valores;Jur;Juros;Dsc;Descontos');

Análise:
O segundo parâmetro contém uma string com os campos e seus respectivos títulos, separados por ponto e vírgula. O padrão é NomeDoCampo1;Titulo1;NomeDoCampo2;Titulo2....

SINTAXE 4: TOTALIZAR MÚLTIPLAS COLUNAS COM AGRUPAMENTO
Esta é a forma mais avançada, utilizada para totalizar múltiplas colunas, mas agrupando os resultados com base nos valores de um outro campo.
Exemplo de Código:
TotalizarDados(TPag,'Val;Valores;Jur;Juros;Dsc;Descontos','Sta');

Análise:
O terceiro parâmetro opcional ('Sta') é o nome do campo que será usado como critério de agrupamento. O resultado exibirá as somas para cada valor distinto encontrado no campo 'Sta'.

PADRÃO DE NOMENCLATURA PARA FORMULÁRIOS (TELAS)

REGRA GERAL
Todos os arquivos e nomes de formulários (telas) do sistema devem seguir uma estrutura de nomenclatura padrão para garantir a organização e a fácil identificação dos módulos.

ESTRUTURA DO NOME
O nome de um formulário é composto por três partes, seguindo o formato: F + MOD + SEQ

Parte 1: Prefixo Fixo (F)
Todos os nomes de formulários devem obrigatoriamente começar com a letra "F".

Parte 2: Sigla do Módulo (MOD)
As três letras seguintes devem representar uma sigla que identifique o módulo ao qual o formulário pertence (ex: CLI para Clientes, EST para Estoque).

Parte 3: Numeração Sequencial (SEQ)
Os dois últimos caracteres devem ser um número sequencial de até dois dígitos (01 a 99) que indica a ordem do formulário dentro daquele módulo.

EXEMPLOS PRÁTICOS
FCLI01
Primeiro formulário do módulo de Clientes.
FCLI02
Segundo formulário do módulo de Clientes.
FEST01
Primeiro formulário do módulo de Estoque.
FMOV01
Primeiro formulário do módulo de Movimentação.

Ok, vamos refinar esta diretriz de nomenclatura de tabelas e seus componentes Delphi correspondentes.

A estrutura abaixo separa claramente a regra para o banco de dados da regra para o Delphi, tornando a relação entre elas explícita e fácil de entender para o RAG.

PADRÃO DE NOMENCLATURA PARA TABELAS E COMPONENTES DE DADOS

Esta diretriz define o padrão de nomes para as tabelas no banco de dados e para os componentes de acesso a dados (TTable/HproTable) dentro do ambiente de desenvolvimento Delphi.

NOMENCLATURA DE TABELAS NO BANCO DE DADOS

Estrutura do Nome: H + MOD
O nome de uma tabela no banco de dados é composto por duas partes.

Parte 1: Prefixo Fixo (H)
Todas as tabelas do sistema devem obrigatoriamente iniciar com a letra "H".

Parte 2: Sigla do Módulo (MOD)
As três letras seguintes devem representar uma sigla que identifique o conteúdo da tabela.

Exemplos Práticos:
HCLI: Tabela de Clientes.
HFOR: Tabela de Fornecedores.
HPRO: Tabela de Produtos.

Exceção:
Em casos raros, as tabelas podem ter nomes com mais de quatro letras no total, porém esta prática deve ser evitada para manter a consistência do padrão.

NOMENCLATURA DE COMPONENTES DE ACESSO NO DELPHI

Estrutura do Nome: T + MOD
Dentro do Delphi, o componente de acesso à tabela (TTable ou HproTable) correspondente deve seguir uma estrutura similar.

Parte 1: Prefixo Fixo (T)
Todos os componentes de tabela devem iniciar com a letra "T".

Parte 2: Sigla do Módulo (MOD)
As três letras seguintes devem ser a mesma sigla utilizada no nome da tabela no banco de dados.

Exemplos de Correspondência:
TCLI: Componente Delphi para acessar a tabela HCLI.
TFOR: Componente Delphi para acessar a tabela HFOR.
TPRO: Componente Delphi para acessar a tabela HPRO.

Observação:
Para uma lista completa de padronizações, consultar o Anexo I do documento de desenvolvimento.

PADRÃO DE NOMENCLATURA PARA CAMPOS DE TABELAS
REGRA GERAL DE NOMENCLATURA
Por padrão, os nomes de campos nas tabelas do banco de dados devem ser compostos por uma abreviação de três letras.
Esta abreviação deve indicar de forma concisa o conteúdo que será armazenado no campo.
OBJETIVO DA REGRA
A utilização de nomes curtos e padronizados para os campos visa tornar o código-fonte da aplicação mais prático, limpo e de fácil leitura.
EXEMPLOS PRÁTICOS
RAZ: Para armazenar a Razão Social.
END: Para armazenar o Endereço.
NOM: Para armazenar o Nome.
NUM: Para armazenar o Número.
COD: Para armazenar o Código.
EXCEÇÃO À REGRA
Apenas em casos excepcionais a regra de três letras pode ser quebrada. Isso ocorre quando a abreviação de três letras não é suficiente para descrever o campo de forma clara.

Exemplo de exceção: Um campo para armazenar o número do RG, que pode manter o nome RG para maior clareza.

Observação:
Para uma lista completa de padronizações, consultar o Anexo II do documento de desenvolvimento.

PADRÃO DE NOMENCLATURA PARA VARIÁVEIS

REGRA GERAL
Todos os nomes de variáveis locais ou de classe devem seguir uma convenção de nomenclatura baseada em prefixos que indicam o seu tipo de dado.
A estrutura do nome é um prefixo de uma letra minúscula, seguido por um nome descritivo que começa com uma letra maiúscula (padrão CamelCase).

PREFIXOS PADRÃO POR TIPO DE DADO
n
Utilizado para variáveis do tipo numérico, seja inteiro (Integer) ou de ponto flutuante (Float, BCD, Currency).
d
Utilizado para variáveis do tipo Data (Date, DateTime).
c
Utilizado para variáveis do tipo texto (String, Memo, Char).
b
Utilizado para variáveis do tipo lógico (Boolean), que armazenam True ou False.
x
Utilizado para variáveis que representam objetos em geral.

EXEMPLOS PRÁTICOS DE USO

nVal
Variável para armazenar um valor numérico.
nTot
Variável para armazenar um valor total.
dEmi
Variável para armazenar uma data de emissão.
cNom
Variável para armazenar um nome ou uma string.
bArquivoExiste
Variável booleana para indicar a existência de um arquivo.
xListaNomes
Variável do tipo objeto, como TStringList, para armazenar uma lista de nomes.

VARIÁVEIS SEM PADRÃO OBRIGATÓRIO
Conforme o prefixo "x" indica, variáveis que armazenam instâncias de objetos complexos (como componentes visuais ou classes como TStringList) não seguem uma regra rígida além do prefixo, ficando a critério do programador a definição do restante do nome




